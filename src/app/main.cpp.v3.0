#include <QApplication>
#include <QCoreApplication>
#include <QMainWindow>
#include <QWebEngineView>
#include <QWebEngineNavigationRequest>
#include <QWebEnginePage>
#include <QWebEngineSettings>
#include <QTimer>
#include <QWebEngineHistory>
#include <QWebEngineProfile>
#include <QWebEngineScript>
#include <QWebEngineScriptCollection>
#include <QWebEngineCookieStore>
#include <QList>
#include <QStandardPaths>
#include <QUrl>
#include <QString>
#include <QDebug>
#include <QUdpSocket>
#include <QMouseEvent>
#include <QWheelEvent>
#include <QTouchEvent>
#include <QHostAddress>
#include <QPushButton>
#include <QProcess>
#include <QFrame>
#include <QHBoxLayout>
#include <QDateTime>
#include <QRegularExpression>
#include <QWebEngineUrlRequestInterceptor>
#include <QWebEngineUrlRequestInfo>
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonArray>
#include <QRect>
#include <QtGlobal>
#include <QFile>
#include <QDir>
#include <QNetworkCookie>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/sysmacros.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <fcntl.h>
#include <unistd.h>
#include <cstring>
#include <cstdlib>
#include <stdint.h>
// Suppress high-volume flip logs to save resources.
static QtMessageHandler g_prevHandler = nullptr;
static void filteredMessageHandler(QtMsgType type, const QMessageLogContext &ctx, const QString &msg) {
    if (msg.contains(QStringLiteral("[PAGER]"))) {
        return;
    }
    if (g_prevHandler) {
        g_prevHandler(type, ctx, msg);
    }
}

// 前向声明
class WereadBrowser;

// --- 【性能优化】网络请求拦截器 ---
// 条件编译开关：取消注释下行以启用详细资源日志（会影响性能）
// #define WEREAD_DEBUG_RESOURCES

class ResourceInterceptor : public QWebEngineUrlRequestInterceptor {
    Q_OBJECT
public:
    explicit ResourceInterceptor(QObject *parent = nullptr) : QWebEngineUrlRequestInterceptor(parent) {}

    void interceptRequest(QWebEngineUrlRequestInfo &info) override {
        const QString url = info.requestUrl().toString();

#ifdef WEREAD_DEBUG_RESOURCES
        const qint64 reqStartTs = QDateTime::currentMSecsSinceEpoch();
        // 获取资源类型的字符串表示（用于诊断）
        const QString resourceTypeStr = [&]() {
            switch(info.resourceType()) {
                case QWebEngineUrlRequestInfo::ResourceTypeMainFrame: return "MainFrame";
                case QWebEngineUrlRequestInfo::ResourceTypeSubFrame: return "SubFrame";
                case QWebEngineUrlRequestInfo::ResourceTypeStylesheet: return "Stylesheet";
                case QWebEngineUrlRequestInfo::ResourceTypeScript: return "Script";
                case QWebEngineUrlRequestInfo::ResourceTypeImage: return "Image";
                case QWebEngineUrlRequestInfo::ResourceTypeFontResource: return "Font";
                case QWebEngineUrlRequestInfo::ResourceTypeMedia: return "Media";
                case QWebEngineUrlRequestInfo::ResourceTypeXhr: return "XHR";
                default: return "Other";
            }
        }();
        qInfo() << "[RESOURCE_START]" << resourceTypeStr << url.mid(0, 100) << "ts" << reqStartTs;
#endif

        auto resourceTypeStr = [&]() {
            switch(info.resourceType()) {
                case QWebEngineUrlRequestInfo::ResourceTypeMainFrame: return "MainFrame";
                case QWebEngineUrlRequestInfo::ResourceTypeSubFrame: return "SubFrame";
                case QWebEngineUrlRequestInfo::ResourceTypeStylesheet: return "Stylesheet";
                case QWebEngineUrlRequestInfo::ResourceTypeScript: return "Script";
                case QWebEngineUrlRequestInfo::ResourceTypeImage: return "Image";
                case QWebEngineUrlRequestInfo::ResourceTypeFontResource: return "Font";
                case QWebEngineUrlRequestInfo::ResourceTypeMedia: return "Media";
                case QWebEngineUrlRequestInfo::ResourceTypeXhr: return "XHR";
                default: return "Other";
            }
        };

        // Block payment scripts
        if (url.contains(QStringLiteral("midas.gtimg.cn")) ||
            url.contains(QStringLiteral("minipay")) ||
            url.contains(QStringLiteral("cashier.js"))) {
            qWarning() << "[BLOCK]" << resourceTypeStr() << url;
            info.block(true);
            return;
        }

        // Block winktemplaterendersvr fonts/media (KaTeX related)
        if (url.contains(QStringLiteral("/winktemplaterendersvr/")) &&
            (info.resourceType() == QWebEngineUrlRequestInfo::ResourceTypeFontResource ||
             info.resourceType() == QWebEngineUrlRequestInfo::ResourceTypeMedia)) {
            qWarning() << "[BLOCK]" << resourceTypeStr() << url;
            info.block(true);
            return;
        }

        // Block SourceHanSerif heavy fonts (~10MB each)
        if (url.contains(QStringLiteral("SourceHanSerif"))) {
            qWarning() << "[BLOCK]" << resourceTypeStr() << url;
            info.block(true);
            return;
        }

        // 进度接口早期记录（包括 ServiceWorker 发出的请求）
        if (url.contains(QStringLiteral("/web/book/read")) || url.contains(QStringLiteral("getProgress"))) {
            qInfo() << "[PROGRESS_NET]" << resourceTypeStr() << url;
        }

#ifdef WEREAD_DEBUG_RESOURCES
        qInfo() << "[RESOURCE_ALLOWED]" << resourceTypeStr << "ts" << reqStartTs;
#endif
    }
};

// 触摸/鼠标事件日志，排查无触摸反馈；不拦截事件
class TouchLogger : public QObject {
    Q_OBJECT
public:
    explicit TouchLogger(QObject* parent = nullptr) : QObject(parent) {}
protected:
    bool eventFilter(QObject* obj, QEvent* ev) override {
        switch (ev->type()) {
        case QEvent::MouseButtonPress:
        case QEvent::MouseButtonRelease:
        case QEvent::MouseMove: {
            auto *me = static_cast<QMouseEvent*>(ev);
            qInfo() << "[TOUCH_EVT] mouse"
                    << (ev->type() == QEvent::MouseButtonPress ? "press" :
                        ev->type() == QEvent::MouseButtonRelease ? "release" : "move")
                    << "pos" << me->position() << "global" << me->globalPosition();
            break;
        }
        case QEvent::TouchBegin:
        case QEvent::TouchUpdate:
        case QEvent::TouchEnd: {
            auto *te = static_cast<QTouchEvent*>(ev);
            if (!te->points().isEmpty()) {
                const auto &pt = te->points().first();
                qInfo() << "[TOUCH_EVT] touch"
                        << (ev->type() == QEvent::TouchBegin ? "begin" :
                            ev->type() == QEvent::TouchEnd ? "end" : "update")
                        << "pos" << pt.position() << "global" << pt.globalPosition()
                        << "state" << pt.state();
            } else {
                qInfo() << "[TOUCH_EVT] touch event with no points";
            }
            break;
        }
        default:
            break;
        }
        return QObject::eventFilter(obj, ev);
    }
};

#if 0
// 简易触摸/鼠标手势过滤：本地处理翻页与滚动，避免依赖后端 UDP。
class GestureFilter : public QObject {
    Q_OBJECT
public:
    explicit GestureFilter(WereadBrowser* browser, QObject* parent = nullptr)
        : QObject(parent), m_browser(browser) {}
protected:
    bool eventFilter(QObject* obj, QEvent* ev) override {
        if (!m_browser) return QObject::eventFilter(obj, ev);
        switch (ev->type()) {
        case QEvent::MouseButtonPress: {
            auto *me = static_cast<QMouseEvent*>(ev);
            m_pressed = true;
            m_startPos = me->position();
            m_timer.restart();
            m_timer.start();
            return true; // 拦截，后续我们自己注入点击/滚动
        }
        case QEvent::MouseMove: {
            // 保留，移动时不处理，等 release 判定
            return true;
        }
        case QEvent::MouseButtonRelease: {
            auto *me = static_cast<QMouseEvent*>(ev);
            if (!m_pressed) return true;
            m_pressed = false;
            QPointF pos = me->position();
            const qreal dx = pos.x() - m_startPos.x();
            const qreal dy = pos.y() - m_startPos.y();
            const qreal absDx = qAbs(dx);
            const qreal absDy = qAbs(dy);
            const qint64 ms = m_timer.isValid() ? m_timer.elapsed() : 0;
            const qreal swipeX = 120.0;
            const qreal swipeY = 140.0;
            // 水平滑动 -> 翻页
            if (absDx > swipeX && absDy < 200.0) {
                if (dx < 0) {
                    m_browser->goNextPage();
                } else {
                    m_browser->goPrevPage();
                }
            }
            // 垂直滑动 -> 滚动
            else if (absDy > swipeY) {
                m_browser->scrollByJs(static_cast<int>(dy));
            }
            // 轻点 -> 注入点击
            else if (ms < 500 && absDx < 40 && absDy < 40) {
                m_browser->injectMouse(Qt::LeftButton, QEvent::MouseButtonPress, pos);
                m_browser->injectMouse(Qt::LeftButton, QEvent::MouseButtonRelease, pos);
            }
            return true;
        }
        case QEvent::TouchBegin:
        case QEvent::TouchUpdate:
        case QEvent::TouchEnd: {
            auto *te = static_cast<QTouchEvent*>(ev);
            if (te->points().isEmpty()) return true;
            const QPointF pos = te->points().first().position();
            if (ev->type() == QEvent::TouchBegin) {
                m_pressed = true;
                m_startPos = pos;
                m_timer.restart(); m_timer.start();
                return true;
            }
            if (ev->type() == QEvent::TouchEnd) {
                if (!m_pressed) return true;
                m_pressed = false;
                const qreal dx = pos.x() - m_startPos.x();
                const qreal dy = pos.y() - m_startPos.y();
                const qreal absDx = qAbs(dx);
                const qreal absDy = qAbs(dy);
                const qint64 ms = m_timer.isValid() ? m_timer.elapsed() : 0;
                const qreal swipeX = 120.0;
                const qreal swipeY = 140.0;
                if (absDx > swipeX && absDy < 200.0) {
                    if (dx < 0) m_browser->goNextPage(); else m_browser->goPrevPage();
                } else if (absDy > swipeY) {
                    m_browser->scrollByJs(static_cast<int>(dy));
                } else if (ms < 500 && absDx < 40 && absDy < 40) {
                    m_browser->injectMouse(Qt::LeftButton, QEvent::MouseButtonPress, pos);
                    m_browser->injectMouse(Qt::LeftButton, QEvent::MouseButtonRelease, pos);
                }
                return true;
            }
            return true;
        }
        default:
            break;
        }
        return QObject::eventFilter(obj, ev);
    }
private:
    WereadBrowser* m_browser = nullptr;
    QPointF m_startPos;
    bool m_pressed = false;
    QElapsedTimer m_timer;
};
#endif
// Smart E-ink refresh helper with waveform selection (KOReader-style).
// 参考 KOReader framebuffer_mxcfb.lua 和 2.0 后端 FbUpdateTrigger 实现。
// 依赖 appload/qtfb-shim 拦截并路由刷新，因此只需发标准 ioctl。
class EinkRefreshHelper {
public:
    // 波形模式 (参考 KOReader mxcfb_remarkable_h.lua)
    enum WaveformMode {
        WAVE_INIT = 0,   // 初始化
        WAVE_DU   = 1,   // Direct Update - 快速，用于高亮/菜单
        WAVE_GC16 = 2,   // Grayscale Clear 16 - 高质量，用于翻页/全刷
        WAVE_GL16 = 3,   // Grayscale Low 16 - 中等质量，用于局部更新
        WAVE_A2   = 4,   // Animation 2 - 极快二值，用于滚动动画
        WAVE_AUTO = 257  // 自动选择
    };
    // 更新模式
    enum UpdateMode {
        MODE_PARTIAL = 0,  // 局部更新
        MODE_FULL    = 1   // 全屏刷新（带闪烁）
    };

    EinkRefreshHelper() {
        ensureFb();
        m_fd = ::open("/dev/fb0", O_RDWR);
        if (m_fd < 0) {
            qWarning() << "[EINK] open fb0 failed" << strerror(errno);
        } else {
            qInfo() << "[EINK] fb0 opened, smart refresh enabled";
        }
        m_lastRefreshTime.start();
    }
    ~EinkRefreshHelper() {
        if (m_fd >= 0) ::close(m_fd);
    }

    // === 高层 API：根据场景自动选择波形 ===

    // 全屏高质量刷新（翻页、加载完成）- GC16 FULL
    void refreshFull(int w, int h) {
        qInfo() << "[EINK] Full refresh (GC16 FULL)" << w << "x" << h;
        triggerRegion(0, 0, w, h, WAVE_GC16, MODE_FULL, false);  // 移除等待，避免阻塞主线程
        resetCounters();
    }

    // 局部高质量刷新（小范围变化）- GL16 PARTIAL
    void refreshPartial(int x, int y, int w, int h) {
        qInfo() << "[EINK] Partial refresh (GL16)" << x << y << w << h;
        triggerRegion(x, y, w, h, WAVE_GL16, MODE_PARTIAL, false);
        m_partialCount++;
        // Cleanup逻辑由SmartRefreshManager统一管理，这里不再检查
    }

    // UI 快速刷新（菜单高亮）- DU PARTIAL
    void refreshUI(int x, int y, int w, int h) {
        qInfo() << "[EINK] UI refresh (DU)" << x << y << w << h;
        triggerRegion(x, y, w, h, WAVE_DU, MODE_PARTIAL, false);
        m_partialCount++;
    }

    // 极快刷新（滚动动画）- A2 PARTIAL
    void refreshA2(int x, int y, int w, int h) {
        qInfo() << "[EINK] A2 refresh (fast scroll)" << x << y << w << h;
        triggerRegion(x, y, w, h, WAVE_A2, MODE_PARTIAL, false);
        m_a2Count++;
        // Cleanup逻辑由SmartRefreshManager统一管理，这里不再检查
    }

    // 滚动刷新：根据滚动频率自动选择 A2 或 GL16
    void refreshScroll(int w, int h) {
        qint64 elapsed = m_lastRefreshTime.elapsed();
        m_lastRefreshTime.restart();
        
        if (elapsed < 200) {
            // 快速连续滚动：用 A2 追求速度
            qInfo() << "[EINK] Fast scroll (A2)" << elapsed << "ms since last";
            triggerRegion(0, 0, w, h, WAVE_A2, MODE_PARTIAL, false);
            m_a2Count++;
        } else {
            // 普通滚动：用 GL16 保证质量
            qInfo() << "[EINK] Normal scroll (GL16)" << elapsed << "ms since last";
            triggerRegion(0, 0, w, h, WAVE_GL16, MODE_PARTIAL, false);
            m_partialCount++;
        }
        // Cleanup逻辑由SmartRefreshManager统一管理，这里不再检查
    }

    // 强制清理刷新（清除残影）- 使用最彻底的 INIT FULL 模式
    void refreshCleanup(int w, int h) {
        qInfo() << "[EINK] Cleanup refresh (INIT FULL) - most thorough refresh for clearing ghosting";
        triggerRegion(0, 0, w, h, WAVE_INIT, MODE_FULL, false);  // 移除等待，避免阻塞主线程
        resetCounters();
    }

    // 检查是否需要清理刷新
    bool needsCleanup() const {
        return m_partialCount >= kMaxPartialBeforeCleanup || 
               m_a2Count >= kMaxA2BeforeCleanup;
    }

    // 获取计数器状态
    int partialCount() const { return m_partialCount; }
    int a2Count() const { return m_a2Count; }

private:
    struct mxcfb_rect { uint32_t top, left, width, height; };
    struct mxcfb_update_data {
        mxcfb_rect update_region;
        uint32_t waveform_mode;
        uint32_t update_mode;
        uint32_t update_marker;
        uint32_t temp;
        uint32_t flags;
        struct { uint32_t phys_addr; uint32_t width; uint32_t height; uint32_t stride; uint32_t pixel_fmt; } alt_buffer_data{};
    };
    struct mxcfb_update_marker_data {
        uint32_t update_marker;
        uint32_t collision_test;
    };

    static constexpr unsigned long MXCFB_SEND_UPDATE = 1078478382UL; // 0x4048462e
    static constexpr unsigned long MXCFB_WAIT_FOR_UPDATE_COMPLETE = 3221767727UL;
    static constexpr int TEMP_USE_AMBIENT = 4096;
    static constexpr int TEMP_USE_REMARKABLE = 24; // 用于 DU 模式
    
    // 清理阈值（参考 2.0 后端）
    static constexpr int kMaxPartialBeforeCleanup = 10;
    static constexpr int kMaxA2BeforeCleanup = 10;

    void ensureFb() {
        struct stat st{};
        if (::stat("/dev/fb0", &st) == 0 && S_ISCHR(st.st_mode)) return;
        if (::mknod("/dev/fb0", S_IFCHR | 0666, makedev(29, 0)) != 0) {
            qWarning() << "[EINK] mknod /dev/fb0 failed" << strerror(errno);
        } else {
            ::chmod("/dev/fb0", 0666);
            qInfo() << "[EINK] created /dev/fb0";
        }
    }

    void triggerRegion(int x, int y, int w, int h, int wave, int mode, bool waitComplete) {
        if (m_fd < 0) return;
        
        mxcfb_update_data upd{};
        upd.update_region.left = static_cast<uint32_t>(x);
        upd.update_region.top = static_cast<uint32_t>(y);
        upd.update_region.width = static_cast<uint32_t>(w);
        upd.update_region.height = static_cast<uint32_t>(h);
        upd.waveform_mode = static_cast<uint32_t>(wave);
        upd.update_mode = static_cast<uint32_t>(mode);
        // DU 模式用固定温度以降低延迟（参考 KOReader）
        upd.temp = (wave == WAVE_DU) ? TEMP_USE_REMARKABLE : TEMP_USE_AMBIENT;
        upd.flags = 0;
        upd.update_marker = ++m_marker;
        
        const char* waveStr = (wave == WAVE_INIT) ? "INIT" :
                              (wave == WAVE_GC16) ? "GC16" :
                              (wave == WAVE_GL16) ? "GL16" :
                              (wave == WAVE_DU)   ? "DU" :
                              (wave == WAVE_A2)   ? "A2" : "AUTO";
        const char* modeStr = (mode == MODE_FULL) ? "FULL" : "PARTIAL";
        
        if (::ioctl(m_fd, MXCFB_SEND_UPDATE, &upd) != 0) {
            qWarning() << "[EINK] send failed" << strerror(errno);
            return;
        }
        
        // 全屏刷新时等待完成（参考 KOReader mxc_update）
        if (waitComplete) {
            mxcfb_update_marker_data md{};
            md.update_marker = upd.update_marker;
            md.collision_test = 0;
            if (::ioctl(m_fd, MXCFB_WAIT_FOR_UPDATE_COMPLETE, &md) != 0) {
                qWarning() << "[EINK] wait failed" << strerror(errno);
            }
        }
        
        qInfo() << "[EINK]" << waveStr << modeStr
                << "region" << x << y << w << h
                << "marker" << upd.update_marker
                << (waitComplete ? "(waited)" : "");
    }

    void resetCounters() {
        m_partialCount = 0;
        m_a2Count = 0;
    }

    void checkCleanupNeeded() {
        if (needsCleanup()) {
            qInfo() << "[EINK] Cleanup threshold reached: partial=" << m_partialCount 
                    << "a2=" << m_a2Count;
        }
    }

    int m_fd = -1;
    uint32_t m_marker = 0;
    int m_partialCount = 0;
    int m_a2Count = 0;
    QElapsedTimer m_lastRefreshTime;
};

// 保留旧名称兼容性
using FbRefreshHelper = EinkRefreshHelper;

// ============================================================================
// 智能刷新管理器 (SmartRefreshManager)
// 三层架构：DOM 监听 → 事件队列 → 决策引擎 → 刷新执行
// 参考：KOReader 刷新策略、用户优化建议
// ============================================================================
class SmartRefreshManager : public QObject {
    Q_OBJECT
public:
    // 三档策略模式
    enum RefreshPolicy {
        PolicyReadingFirst,     // 阅读优先：多GC16，清晰
        PolicyInteractionFirst, // 交互优先：多A2，流畅
        PolicySmartBalance      // 智能平衡：自动适应（默认）
    };

    // 波形选择
    enum WaveformChoice {
        WF_NONE,
        WF_A2,
        WF_DU,
        WF_GL16,
        WF_GC16_PARTIAL,
        WF_GC16_FULL
    };

    // 刷新事件类型
    struct RefreshEvent {
        enum Type { 
            DOM_CHANGE,      // DOM 变化
            SCROLL,          // 滚动
            PAGE_TURN,       // 翻页
            MENU,            // 菜单
            LOAD_FINISHED,   // 加载完成
            BURST_END,       // 猝发结束
            IDLE,            // 空闲
            CONTENT_READY    // 内容准备好
        };
        Type type = DOM_CHANGE;
        int score = 0;           // DOM 变化分数
        int scrollDelta = 0;     // 滚动距离
        QRect region;            // 变化区域（可选）
    };

    explicit SmartRefreshManager(FbRefreshHelper* fb, int w, int h, QObject* parent = nullptr)
        : QObject(parent), m_fb(fb), m_width(w), m_height(h) {
        // 批处理定时器：100ms 窗口
        m_batchTimer.setSingleShot(true);
        m_batchTimer.setInterval(100);
        connect(&m_batchTimer, &QTimer::timeout, this, &SmartRefreshManager::processBatch);

        // 空闲检测定时器：30秒无操作
        m_idleTimer.setSingleShot(true);
        m_idleTimer.setInterval(30000);
        connect(&m_idleTimer, &QTimer::timeout, this, &SmartRefreshManager::onIdle);

        m_lastFullRefresh.start();
        m_lastActivityTime.start();
        qInfo() << "[SMART_REFRESH] Manager initialized, policy=SmartBalance";
    }

    void setPolicy(RefreshPolicy policy) {
        m_policy = policy;
        const char* policyStr = (policy == PolicyReadingFirst) ? "ReadingFirst" :
                                (policy == PolicyInteractionFirst) ? "InteractionFirst" : "SmartBalance";
        qInfo() << "[SMART_REFRESH] Policy changed to" << policyStr;
    }

    RefreshPolicy policy() const { return m_policy; }

    // 设置是否在书籍页面
    void setBookPage(bool isBook) {
        m_isBookPage = isBook;
        if (!isBook) {
            // 离开书籍页面时，重置递增阈值机制
            m_lastRefreshScore = 0;
            m_clickPending = false;
            qInfo() << "[SMART_REFRESH] Left book page, score threshold reset";
        } else {
            qInfo() << "[SMART_REFRESH] Entered book page, incremental threshold enabled";
        }
    }

    // 重置score阈值（仅在书籍页面生效）
    void resetScoreThreshold() {
        if (!m_isBookPage) {
            qInfo() << "[SMART_REFRESH] resetScoreThreshold called but not in book page, ignored";
            return;
        }
        m_lastRefreshScore = 0;
        m_clickPending = true;
        qInfo() << "[SMART_REFRESH] Score threshold reset (click detected in book page)";
    }

    // 推送刷新事件
    void pushEvent(const RefreshEvent& event) {
        const char* typeStr = (event.type == RefreshEvent::DOM_CHANGE) ? "DOM_CHANGE" :
                              (event.type == RefreshEvent::SCROLL) ? "SCROLL" :
                              (event.type == RefreshEvent::PAGE_TURN) ? "PAGE_TURN" :
                              (event.type == RefreshEvent::MENU) ? "MENU" :
                              (event.type == RefreshEvent::LOAD_FINISHED) ? "LOAD_FINISHED" :
                              (event.type == RefreshEvent::BURST_END) ? "BURST_END" :
                              (event.type == RefreshEvent::IDLE) ? "IDLE" :
                              (event.type == RefreshEvent::CONTENT_READY) ? "CONTENT_READY" : "UNKNOWN";
        qInfo() << "[SMART_REFRESH] pushEvent: type=" << typeStr
                << "score=" << event.score
                << "scrollDelta=" << event.scrollDelta
                << "region=" << (event.region.isNull() ? "null" : QString("%1,%2 %3x%4").arg(event.region.x()).arg(event.region.y()).arg(event.region.width()).arg(event.region.height()));

        m_eventQueue.append(event);
        m_lastActivityTime.restart();
        m_idleTimer.start(); // 重置空闲定时器

        // 高优先级事件处理
        if (event.type == RefreshEvent::LOAD_FINISHED ||
            event.type == RefreshEvent::BURST_END ||
            event.type == RefreshEvent::CONTENT_READY) {
            qInfo() << "[SMART_REFRESH] High priority event, processing immediately";
            processBatch();
            return;
        }
        
        // PAGE_TURN 不再特殊处理，进入批处理队列，等待JS的DOM变化事件一起处理
        // （移除延迟100ms的特殊处理，让智能刷新完全由JS驱动）

        // 其他事件进入批处理窗口
        if (!m_batchTimer.isActive()) {
            qInfo() << "[SMART_REFRESH] Starting batch timer (100ms)";
            m_batchTimer.start();
        } else {
            qInfo() << "[SMART_REFRESH] Batch timer already active, event queued";
        }
    }

    // 从 JS console 消息解析事件
    void parseJsEvents(const QString& json) {
        qInfo() << "[SMART_REFRESH] parseJsEvents received JSON:" << json;
        QJsonParseError err;
        QJsonDocument doc = QJsonDocument::fromJson(json.toUtf8(), &err);
        if (err.error != QJsonParseError::NoError) {
            qWarning() << "[SMART_REFRESH] JSON parse error:" << err.errorString() << "JSON:" << json;
            return;
        }

        if (!doc.isArray()) {
            qWarning() << "[SMART_REFRESH] JSON is not an array:" << json;
            return;
        }

        QJsonArray arr = doc.array();
        qInfo() << "[SMART_REFRESH] Parsed" << arr.size() << "events from JS";
        int eventCount = 0;
        for (const QJsonValue& val : arr) {
            if (!val.isObject()) continue;
            QJsonObject obj = val.toObject();
            QString type = obj.value("t").toString();
            
            RefreshEvent event;
            if (type == "dom") {
                event.type = RefreshEvent::DOM_CHANGE;
                event.score = obj.value("s").toInt();
                qInfo() << "[SMART_REFRESH] DOM event: score=" << event.score;
                // 解析区域（如果有）
                QJsonArray regions = obj.value("r").toArray();
                if (!regions.isEmpty()) {
                    // 合并所有区域为一个包围盒
                    int minX = INT_MAX, minY = INT_MAX, maxX = 0, maxY = 0;
                    for (const QJsonValue& rv : regions) {
                        QJsonObject r = rv.toObject();
                        int x = r.value("x").toInt();
                        int y = r.value("y").toInt();
                        int w = r.value("w").toInt();
                        int h = r.value("h").toInt();
                        minX = qMin(minX, x);
                        minY = qMin(minY, y);
                        maxX = qMax(maxX, x + w);
                        maxY = qMax(maxY, y + h);
                    }
                    if (minX < INT_MAX) {
                        event.region = QRect(minX, minY, maxX - minX, maxY - minY);
                        qInfo() << "[SMART_REFRESH] DOM region:" << event.region;
                    }
                }
            } else if (type == "scroll") {
                event.type = RefreshEvent::SCROLL;
                // JS 发送的是浮点数，需要先转 double 再转 int
                event.scrollDelta = static_cast<int>(obj.value("d").toDouble());
                qInfo() << "[SMART_REFRESH] SCROLL event: delta=" << event.scrollDelta << "raw=" << obj.value("d").toString();
            } else {
                qInfo() << "[SMART_REFRESH] Unknown event type:" << type;
                continue;
            }
            pushEvent(event);
            eventCount++;
        }
        qInfo() << "[SMART_REFRESH] Pushed" << eventCount << "events to queue, queueSize=" << m_eventQueue.size();
    }

    // 直接触发特定类型事件
    void triggerPageTurn() {
        RefreshEvent e;
        e.type = RefreshEvent::PAGE_TURN;
        pushEvent(e);
    }

    void triggerLoadFinished() {
        RefreshEvent e;
        e.type = RefreshEvent::LOAD_FINISHED;
        pushEvent(e);
    }

    void triggerMenu() {
        RefreshEvent e;
        e.type = RefreshEvent::MENU;
        pushEvent(e);
    }

    void triggerBurstEnd() {
        RefreshEvent e;
        e.type = RefreshEvent::BURST_END;
        pushEvent(e);
    }

    void triggerContentReady() {
        RefreshEvent e;
        e.type = RefreshEvent::CONTENT_READY;
        pushEvent(e);
    }

    // 获取状态
    float ghostingRisk() const { return m_ghostingRisk; }
    int partialCount() const { return m_partialCount; }
    int a2Count() const { return m_a2Count; }

private slots:
    void processBatch() {
        if (m_eventQueue.isEmpty()) {
            qInfo() << "[SMART_REFRESH] processBatch: queue is empty, skipping";
            return;
        }

        qInfo() << "[SMART_REFRESH] processBatch: processing" << m_eventQueue.size() << "events";
        for (int i = 0; i < m_eventQueue.size(); ++i) {
            const auto& e = m_eventQueue[i];
            const char* typeStr = (e.type == RefreshEvent::DOM_CHANGE) ? "DOM_CHANGE" :
                                  (e.type == RefreshEvent::SCROLL) ? "SCROLL" :
                                  (e.type == RefreshEvent::PAGE_TURN) ? "PAGE_TURN" :
                                  (e.type == RefreshEvent::MENU) ? "MENU" :
                                  (e.type == RefreshEvent::LOAD_FINISHED) ? "LOAD_FINISHED" :
                                  (e.type == RefreshEvent::BURST_END) ? "BURST_END" :
                                  (e.type == RefreshEvent::IDLE) ? "IDLE" :
                                  (e.type == RefreshEvent::CONTENT_READY) ? "CONTENT_READY" : "UNKNOWN";
            qInfo() << "[SMART_REFRESH]   Event" << i << ":" << typeStr << "score=" << e.score << "scrollDelta=" << e.scrollDelta;
        }

        // 决策
        WaveformChoice wf = decideWaveform(m_eventQueue);
        QRect mergedRegion = mergeRegions();

        qInfo() << "[SMART_REFRESH] Decision: waveform=" << static_cast<int>(wf) << "region=" << (mergedRegion.isNull() ? "fullscreen" : QString("%1,%2 %3x%4").arg(mergedRegion.x()).arg(mergedRegion.y()).arg(mergedRegion.width()).arg(mergedRegion.height()));

        // 执行刷新
        executeRefresh(wf, mergedRegion);

        // 只有在刷新成功时才清空队列（非书籍页面总是清空）
        if (wf != WF_NONE) {
            m_eventQueue.clear();
            qInfo() << "[SMART_REFRESH] Queue cleared after refresh";
        } else {
            // 在书籍页面，不刷新时保留事件；非书籍页面清空
            if (m_isBookPage) {
                qInfo() << "[SMART_REFRESH] No refresh in book page, keeping" << m_eventQueue.size() << "events in queue";
            } else {
                m_eventQueue.clear();
                qInfo() << "[SMART_REFRESH] No refresh, queue cleared";
            }
        }
    }

    void onIdle() {
        // 30秒无操作，检查是否需要清理残影
        if (m_ghostingRisk > 5.0f) {
            qInfo() << "[SMART_REFRESH] Idle cleanup, ghostingRisk=" << m_ghostingRisk;
            RefreshEvent e;
            e.type = RefreshEvent::IDLE;
            pushEvent(e);
        }
    }

private:
    WaveformChoice decideWaveform(const QVector<RefreshEvent>& events) {
        // 1. 检查高优先级事件（高优先级事件不受递增阈值限制）
        bool hasHighPriorityEvent = false;
        for (const auto& e : events) {
            if (e.type == RefreshEvent::PAGE_TURN) {
                return WF_A2;  // 翻页使用 A2 剧刷（快速刷新）
            }
            if (e.type == RefreshEvent::LOAD_FINISHED) {
                hasHighPriorityEvent = true;
                // 页面加载完成：首次加载用全刷，后续导航用局部刷新
                // 检查是否距离上次全刷很久（>5秒），如果是则全刷，否则局部刷新
                if (m_lastFullRefresh.elapsed() > 5000) {
                    return WF_GC16_FULL;
                } else {
                    return WF_GC16_PARTIAL;  // 快速导航，用局部刷新
                }
            }
            if (e.type == RefreshEvent::BURST_END) {
                hasHighPriorityEvent = true;
                // 猝发结束：根据 ghosting 风险决定
                return (m_ghostingRisk > 0.5f) ? WF_GC16_FULL : WF_GC16_PARTIAL;
            }
            if (e.type == RefreshEvent::MENU) {
                hasHighPriorityEvent = true;
                return WF_GC16_PARTIAL;
            }
            if (e.type == RefreshEvent::IDLE && m_ghostingRisk > 5.0f) {
                hasHighPriorityEvent = true;
                return WF_GC16_FULL;
            }
            if (e.type == RefreshEvent::CONTENT_READY) {
                hasHighPriorityEvent = true;
                // 内容准备好时，使用局部刷新显示内容（不受递增阈值限制）
                // 同时重置阈值，确保后续的DOM变化能够刷新
                m_lastRefreshScore = 0;
                m_clickPending = false;
                qInfo() << "[SMART_REFRESH] CONTENT_READY detected, resetting score threshold";
                return WF_GC16_PARTIAL;
            }
        }

        // 2. 汇总 DOM 和滚动变化
        int totalScore = 0;
        int totalScrollDelta = 0;
        bool hasDOMChange = false;
        for (const auto& e : events) {
            totalScore += e.score;
            totalScrollDelta += e.scrollDelta;
            if (e.type == RefreshEvent::DOM_CHANGE) {
                hasDOMChange = true;
            }
        }

        // 3. 根据策略模式调整决策
        if (m_policy == PolicyReadingFirst) {
            // 阅读优先：偏向清晰，降低使用 A2 的阈值
            if (totalScore > 30 || totalScrollDelta > 100) return WF_GC16_PARTIAL;
            if (totalScore > 10) return WF_GL16;
            return WF_NONE;
        } else if (m_policy == PolicyInteractionFirst) {
            // 交互优先：偏向流畅，多用 A2
            if (totalScrollDelta > 50) return WF_A2;
            if (totalScore > 100) return WF_GL16;
            if (totalScore > 20) return WF_A2;
            return WF_NONE;
        }

        // 4. 智能平衡模式：根据 ghosting 风险动态调整
        float riskMultiplier = 1.0f + m_ghostingRisk;

        // 滚动处理
        if (totalScrollDelta > 200) {
            qint64 elapsed = m_lastRefreshTime.elapsed();
            return (elapsed < 200) ? WF_A2 : WF_GL16;
        }

        // DOM 变化处理
        int adjustedScore = static_cast<int>(totalScore * riskMultiplier);
        
        // 递增阈值检查（仅在书籍页面且是DOM_CHANGE事件时生效，高优先级事件不受限制）
        if (m_isBookPage && hasDOMChange && !hasHighPriorityEvent) {
            // 优先检查：高分变化（>100，使用adjustedScore）强制刷新，跳过递增阈值限制
            if (adjustedScore > 100) {
                qInfo() << "[SMART_REFRESH] High score change" << adjustedScore 
                        << "> 100, forcing refresh (bypassing incremental threshold)";
                // 高分变化时，清除点击待处理标志，阈值将在刷新后更新
                m_clickPending = false;
                // 继续正常决策流程（不return，继续执行下面的决策逻辑）
            } else if (m_clickPending) {
                // 点击时阈值已重置为0，清除点击待处理标志，允许第一次刷新
                m_clickPending = false;
                qInfo() << "[SMART_REFRESH] Click detected in book page, threshold is 0, allowing refresh";
            } else if (m_lastRefreshScore > 0 && totalScore < m_lastRefreshScore) {
                // 使用原始DOM Score比较，确保相同DOM变化（如16分）时阈值一致
                // score小于阈值，不刷新，但保留事件等待下一次点击或更大的score
                // 如果score >= 阈值，则执行刷新
                qInfo() << "[SMART_REFRESH] Raw DOM score" << totalScore 
                        << "< last refresh score" << m_lastRefreshScore 
                        << "(adjusted=" << adjustedScore << "), skipping refresh (will refresh on next click or larger score)";
                return WF_NONE;
            }
        }

        // 正常决策逻辑（所有页面都适用）
        if (adjustedScore > 300) return WF_GC16_PARTIAL;
        if (adjustedScore > 80) return WF_GL16;
        if (adjustedScore > 10) return WF_A2;

        return WF_NONE;
    }

    QRect mergeRegions() {
        int minX = INT_MAX, minY = INT_MAX, maxX = 0, maxY = 0;
        bool hasRegion = false;

        for (const auto& e : m_eventQueue) {
            if (!e.region.isNull()) {
                hasRegion = true;
                minX = qMin(minX, e.region.x());
                minY = qMin(minY, e.region.y());
                maxX = qMax(maxX, e.region.x() + e.region.width());
                maxY = qMax(maxY, e.region.y() + e.region.height());
            }
        }

        if (hasRegion && minX < INT_MAX) {
            // 扩展边界以避免边缘残影
            const int padding = 10;
            minX = qMax(0, minX - padding);
            minY = qMax(0, minY - padding);
            maxX = qMin(m_width, maxX + padding);
            maxY = qMin(m_height, maxY + padding);
            return QRect(minX, minY, maxX - minX, maxY - minY);
        }

        return QRect(); // 空区域表示全屏
    }

    void executeRefresh(WaveformChoice wf, const QRect& region) {
        if (wf == WF_NONE) {
            // 不刷新时，在书籍页面保留事件在队列中，等待下一次点击或更大的score
            if (m_isBookPage) {
                qInfo() << "[SMART_REFRESH] No refresh in book page, keeping events in queue for next click or larger score";
            } else {
                qInfo() << "[SMART_REFRESH] No refresh, clearing queue";
                m_eventQueue.clear();
            }
            return;
        }

        // 刷新前检查：如果达到cleanup阈值，强制全刷
        bool needCleanup = false;
        if (m_partialCount >= m_maxPartialBeforeCleanup ||
            m_a2Count >= m_maxA2BeforeCleanup) {
            needCleanup = true;
            qInfo() << "[SMART_REFRESH] Cleanup threshold reached before refresh:"
                    << "partial=" << m_partialCount
                    << "a2=" << m_a2Count
                    << ", forcing GC16_FULL";
        }
        if (m_ghostingRisk >= 5.0f) {
            needCleanup = true;
            qInfo() << "[SMART_REFRESH] Cleanup threshold reached before refresh:"
                    << "ghostingRisk=" << m_ghostingRisk
                    << ", forcing GC16_FULL";
        }
        
        if (needCleanup) {
            wf = WF_GC16_FULL;  // 强制全刷，不管原定的刷新类型
        }

        bool isFullScreen = region.isNull() ||
            (region.width() >= m_width * 0.8 && region.height() >= m_height * 0.8);

        const char* wfStr = (wf == WF_A2) ? "A2" :
                           (wf == WF_DU) ? "DU" :
                           (wf == WF_GL16) ? "GL16" :
                           (wf == WF_GC16_PARTIAL) ? "GC16_PARTIAL" :
                           (wf == WF_GC16_FULL) ? "GC16_FULL" : "NONE";

        qInfo() << "[SMART_REFRESH] Execute" << wfStr
                << "region" << (isFullScreen ? "fullscreen" : QString("%1,%2 %3x%4").arg(region.x()).arg(region.y()).arg(region.width()).arg(region.height()))
                << "ghostingRisk" << m_ghostingRisk
                << "partialCount" << m_partialCount
                << "a2Count" << m_a2Count;

        // 更新本次刷新的score阈值（仅在书籍页面用于下次比较）
        // 注意：阈值使用原始DOM Score，不包含ghostingRisk乘数，以确保相同DOM变化时阈值一致
        // 阈值只在刷新执行后更新，用于控制两次点击之间的刷新频率
        // 点击时阈值会重置为0（通过resetScoreThreshold()），允许第一次刷新
        if (m_isBookPage) {
            int currentScore = 0;
            bool hasDOMChange = false;
            for (const auto& e : m_eventQueue) {
                if (e.type == RefreshEvent::DOM_CHANGE) {
                    currentScore += e.score;
                    hasDOMChange = true;
                }
            }
            if (hasDOMChange && currentScore > 0) {
                // 使用原始DOM Score作为阈值，不包含ghostingRisk乘数
                // 这样即使ghostingRisk累积，相同DOM变化（如16分）的阈值保持一致
                m_lastRefreshScore = currentScore;
                qInfo() << "[SMART_REFRESH] Updated last refresh score threshold to" << m_lastRefreshScore 
                        << "(raw DOM score, book page)";
            }
        }

        m_lastRefreshTime.restart();

        switch (wf) {
        case WF_GC16_FULL:
            m_fb->refreshFull(m_width, m_height);
            m_partialCount = 0;
            m_a2Count = 0;
            m_ghostingRisk = 0.0f;
            m_lastFullRefresh.restart();
            break;
        case WF_GC16_PARTIAL:
            if (isFullScreen) {
                m_fb->refreshPartial(0, 0, m_width, m_height);
            } else {
                m_fb->refreshPartial(region.x(), region.y(), region.width(), region.height());
            }
            m_partialCount++;
            m_ghostingRisk += 0.02f;
            break;
        case WF_GL16:
            m_fb->refreshScroll(m_width, m_height);
            m_partialCount++;
            m_ghostingRisk += 0.03f;
            break;
        case WF_A2:
            m_fb->refreshA2(0, 0, m_width, m_height);
            m_a2Count++;
            m_ghostingRisk += 0.05f;
            break;
        case WF_DU:
            m_fb->refreshUI(0, 0, m_width, m_height);
            m_a2Count++;
            m_ghostingRisk += 0.01f;
            break;
        default:
            break;
        }

        // 刷新后只做数据累计，cleanup检查已在刷新前完成
    }

private:
    FbRefreshHelper* m_fb;
    int m_width, m_height;
    RefreshPolicy m_policy = PolicySmartBalance;

    // 事件队列
    QVector<RefreshEvent> m_eventQueue;
    QTimer m_batchTimer;
    QTimer m_idleTimer;

    // 状态跟踪
    int m_partialCount = 0;
    int m_a2Count = 0;
    float m_ghostingRisk = 0.0f;
    QElapsedTimer m_lastFullRefresh;
    QElapsedTimer m_lastRefreshTime;
    QElapsedTimer m_lastActivityTime;

    // 动态阈值
    int m_maxPartialBeforeCleanup = 15;
    int m_maxA2BeforeCleanup = 25;

    // 递增阈值机制（仅在书籍页面生效）
    bool m_isBookPage = false;         // 是否在书籍页面
    int m_lastRefreshScore = 0;        // 上次刷新的score阈值（仅在书籍页面生效）
    bool m_clickPending = false;       // 是否有点击操作待处理（仅在书籍页面生效）
};

void checkMenuPanelState(QWebEnginePage *page) {
    if (!page) return;
    // 简化字符串，避免模板字符串解析歧义
    const QString js = QStringLiteral(
        "(function(){"
        "  const panel=document.querySelector('.set-tool-box');"
        "  if(!panel) return '[CLICK_DEBUG] Panel .set-tool-box NOT found';"
        "  const s=getComputedStyle(panel);"
        "  const r=panel.getBoundingClientRect();"
        "  return '[CLICK_DEBUG] Panel Found. display:' + s.display +"
        "         ' vis:' + s.visibility +"
        "         ' op:' + s.opacity +"
        "         ' z:' + s.zIndex +"
        "         ' Rect: x=' + r.left + ' y=' + r.top + ' w=' + r.width + ' h=' + r.height;"
        "})()"
    );
    page->runJavaScript(js, [](const QVariant &res){
        qInfo().noquote() << res.toString();
    });
}

class RoutedPage : public QWebEnginePage {
    Q_OBJECT
public:
    RoutedPage(QWebEngineProfile* profile, QWebEngineView* view, QObject* parent = nullptr)
        : QWebEnginePage(profile, parent), m_view(view) {}

signals:
    // 智能刷新事件信号
    void smartRefreshEvents(const QString& json);
    void smartRefreshBurstEnd();

protected:
    QWebEnginePage* createWindow(WebWindowType type) override {
        Q_UNUSED(type);
        // Block popups on dedao book pages to prevent navigation away
        const QString currentUrl = m_view ? m_view->url().toString() : QString();
        const bool isDedaoBook = currentUrl.contains(QStringLiteral("dedao.cn")) &&
                                 currentUrl.contains(QStringLiteral("/ebook/reader"));

        if (isDedaoBook) {
            qInfo() << "[WINDOW] blocked popup on dedao book page" << currentUrl;
            return nullptr; // Block the popup
        }

        // For other pages, redirect to main view
        auto *tmp = new QWebEnginePage(profile(), this);
        connect(tmp, &QWebEnginePage::urlChanged, this, [this, tmp](const QUrl &url){
            if (m_view) {
                qInfo() << "[WINDOW] redirect new window to current view" << url;
                m_view->load(url);
            }
            tmp->deleteLater();
        });
        return tmp;
    }
    bool acceptNavigationRequest(const QUrl &url, NavigationType type, bool isMainFrame) override {
        if (!isMainFrame) return true;
        const qint64 ts = QDateTime::currentMSecsSinceEpoch();
        const qint64 rel = m_lastReloadTs ? (ts - m_lastReloadTs) : -1;
        qInfo() << "[NAV] request" << url << "type" << type << "mainFrame" << isMainFrame
                << "ts" << ts << "sinceReload" << rel;
        const QString currentUrl = m_view ? m_view->url().toString() : QString();
        const bool inDedaoReader = currentUrl.contains(QStringLiteral("dedao.cn")) &&
                                   currentUrl.contains(QStringLiteral("/ebook/reader"));
        if (inDedaoReader) {
            const QString target = url.toString();
            const bool sameReader = target.contains(QStringLiteral("dedao.cn")) &&
                                    target.contains(QStringLiteral("/ebook/reader"));
            const bool isDetail = target.contains(QStringLiteral("/ebook/detail"));
            if (!sameReader) {
                qInfo() << "[NAV] block non-reader nav from dedao" << url << "ts" << ts << "sinceReload" << rel;
                return false;
            }
            if (isDetail) {
                qInfo() << "[NAV] block detail nav inside reader" << url << "ts" << ts << "sinceReload" << rel;
                return false;
            }
        }
        return QWebEnginePage::acceptNavigationRequest(url, type, isMainFrame);
    }
    void javaScriptConsoleMessage(JavaScriptConsoleMessageLevel level,
                                  const QString &message,
                                  int lineNumber,
                                  const QString &sourceID) override {
        Q_UNUSED(level);
        // 定向屏蔽 weread 书页的 SyntaxError 噪声，防止日志刷屏
        const bool isWeReadSrc = sourceID.contains(QStringLiteral("weread.qq.com"), Qt::CaseInsensitive);
        if (isWeReadSrc && message.contains(QStringLiteral("SyntaxError"), Qt::CaseInsensitive)) {
            return;
        }

        // 智能刷新事件解析
        if (message.startsWith(QStringLiteral("[REFRESH_EVENTS]"))) {
            const QString json = message.mid(16); // 去掉前缀
            qInfo() << "[SMART_REFRESH] Received REFRESH_EVENTS from JS:" << json;
            emit smartRefreshEvents(json);
            return; // 不再打印到日志，减少噪声
        }
        if (message == QStringLiteral("[REFRESH_BURST_END]")) {
            qInfo() << "[SMART_REFRESH] Received REFRESH_BURST_END from JS";
            emit smartRefreshBurstEnd();
            return;
        }
        if (message.contains(QStringLiteral("[SMART_REFRESH]"))) {
            // 打印智能刷新相关的 JS 日志
            qInfo().noquote() << "[JS_SMART_REFRESH]" << message;
            return;
        }

        qWarning().noquote() << "[JS]" << sourceID << ":" << lineNumber << message;
    }
private:
    QWebEngineView* m_view = nullptr;
    qint64 m_bookEnterTs = 0;
    qint64 m_lastReloadTs = 0; // pointer to browser not available here, so keep local timestamp unused
};

class WereadBrowser : public QMainWindow {
    Q_OBJECT
public:
    WereadBrowser(const QUrl& url, FbRefreshHelper* fbRef = nullptr)
        : QMainWindow(), m_fbRef(fbRef) {
        setWindowTitle("WeRead - Paper Pro");
        // Portrait logical size matching device (width x height)
        resize(954, 1696);
        // Configure profile: allow switching between network URL and local file://
        m_profile = new QWebEngineProfile(QStringLiteral("weread-profile"), this);
        // 启用持久化存储和缓存，实现会话恢复
        QString dataDir = QStandardPaths::writableLocation(QStandardPaths::AppDataLocation);
        QDir().mkpath(dataDir);
        QString cacheDir = dataDir + "/cache";
        QDir().mkpath(cacheDir);
        QString storageDir = dataDir + "/storage";
        QDir().mkpath(storageDir);
        m_profile->setPersistentStoragePath(storageDir);  // LocalStorage, IndexedDB 等
        m_profile->setCachePath(cacheDir);               // HTTP 缓存路径
        m_profile->setPersistentCookiesPolicy(QWebEngineProfile::AllowPersistentCookies);
        m_profile->setHttpCacheType(QWebEngineProfile::DiskHttpCache);  // 启用磁盘缓存
        // 安装请求拦截器，阻断字体 / 统计 / 媒体等资源
        ResourceInterceptor *interceptor = new ResourceInterceptor(this);
        m_profile->setUrlRequestInterceptor(interceptor);
        // 暂时移除所有注入脚本，排查 SyntaxError/空白根因（资源加载/缓存/上游）
        const QString uaDefault = m_profile->httpUserAgent();
        m_kindleUA = QStringLiteral("Mozilla/5.0 (Linux; Kindle Paperwhite) AppleWebKit/537.36 (KHTML, like Gecko) Silk/3.2 Mobile Safari/537.36");
        m_ipadMiniUA = QStringLiteral("Mozilla/5.0 (iPad; CPU OS 17_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1");
        const QString androidUA = QStringLiteral("Mozilla/5.0 (Linux; Android 14; Pixel 8) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Mobile Safari/537.36");
        m_desktopChromeUA = QStringLiteral("Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36");
        const QByteArray uaModeEnv = qgetenv("WEREAD_UA_MODE");
        const QString uaMode = QString::fromLatin1(uaModeEnv);
        const QByteArray bookModeEnv = qgetenv("WEREAD_BOOK_MODE");
        const QString bookMode = QString::fromLatin1(bookModeEnv);
        // 默认 UA：统一使用 Kindle（非书籍页也走触摸友好 UA）
        Q_UNUSED(uaMode);
        m_uaNonWeRead = m_kindleUA;
        // 微信读书书籍页 UA：强制 Kindle，保证按钮/布局可控
        m_weReadBookMode = QStringLiteral("mobile");
        m_uaWeReadBook = m_kindleUA.isEmpty() ? m_uaNonWeRead : m_kindleUA;
        // 初始 UA 先按目标 URL 决定
        m_currentUA = QStringLiteral("unset");
        updateUserAgentForUrl(url);
        qInfo() << "[UA] default" << uaDefault;
        qInfo() << "[UA] mode" << (uaMode.isEmpty() ? QStringLiteral("default") : uaMode)
                << "non-weRead" << m_uaNonWeRead << "weRead-book" << m_uaWeReadBook
                << "bookMode" << m_weReadBookMode;
        qInfo() << "[PROFILE] data" << m_profile->persistentStoragePath()
                << "cache" << m_profile->cachePath()
                << "cookiesPolicy" << m_profile->persistentCookiesPolicy()
                << "offTheRecord" << m_profile->isOffTheRecord();

        m_view = new QWebEngineView(this);
        RoutedPage* routedPage = new RoutedPage(m_profile, m_view, m_view);
        m_view->setPage(routedPage);
        setCentralWidget(m_view);
        m_view->setFixedSize(954, 1696);
        m_view->setFocusPolicy(Qt::StrongFocus);
        m_view->setFocus(Qt::OtherFocusReason);
        // 安装触摸/鼠标日志过滤器，不改变事件流，仅记录
        m_view->installEventFilter(new TouchLogger(m_view));

        // 创建智能刷新管理器
        if (m_fbRef) {
            m_smartRefresh = new SmartRefreshManager(m_fbRef, 954, 1696, this);
            // 连接 RoutedPage 的智能刷新信号
            connect(routedPage, &RoutedPage::smartRefreshEvents, this, [this](const QString& json) {
                if (m_smartRefresh) {
                    m_smartRefresh->parseJsEvents(json);
                }
            });
            connect(routedPage, &RoutedPage::smartRefreshBurstEnd, this, [this]() {
                if (m_smartRefresh) {
                    m_smartRefresh->triggerBurstEnd();
                }
            });
            qInfo() << "[SMART_REFRESH] Connected to RoutedPage signals";
        }
        QWebEngineSettings* settings = m_view->settings();
        // 可通过 WEREAD_DISABLE_JS 临时关闭 JavaScript，验证解析错误
        const bool disableJs = qEnvironmentVariableIsSet("WEREAD_DISABLE_JS");
        settings->setAttribute(QWebEngineSettings::JavascriptEnabled, !disableJs);
        settings->setAttribute(QWebEngineSettings::LocalStorageEnabled, true);
        settings->setAttribute(QWebEngineSettings::PluginsEnabled, false);
        // 允许 window.open；在 createWindow / acceptNavigation 中做定制拦截
        settings->setAttribute(QWebEngineSettings::JavascriptCanOpenWindows, true);
        settings->setAttribute(QWebEngineSettings::ScrollAnimatorEnabled, false);
        settings->setAttribute(QWebEngineSettings::AutoLoadIconsForPage, false);
        // Use moderate zoom for readability; touch mapping accounts for zoom in hittest
        m_view->setZoomFactor(1.6);
        connect(m_view, &QWebEngineView::loadStarted, this, [this](){
            const qint64 ts = QDateTime::currentMSecsSinceEpoch();
            qInfo() << "[TIMING] loadStarted url" << currentUrl << "ts" << ts;
            m_bookEarlyReloads = 0;
            m_iframeFixApplied = false;
            m_diagRan = false;
            m_contentReadyTriggered = false;
            // 注意：cookie 设置已在 urlChanged 时完成，这里不再重复设置
            // 如果设置了 WEREAD_BLANK_HOOK，则直接 setHtml 覆盖空白，彻底绕过远端文档解析
            const QByteArray blankHook = qgetenv("WEREAD_BLANK_HOOK");
            if (!blankHook.isEmpty()) {
                qWarning() << "[HOOK] Applying setHtml blank (WEREAD_BLANK_HOOK set)";
                if (m_view && m_view->page()) {
                    m_view->setHtml(QStringLiteral("<!DOCTYPE html><html><body>blank hook</body></html>"),
                                    QUrl(QStringLiteral("https://weread.qq.com/")));
                }
            }
        });
        connect(m_view, &QWebEngineView::loadProgress, this, [this](int p){
            const qint64 ts = QDateTime::currentMSecsSinceEpoch();
            qInfo() << "[TIMING] loadProgress" << p << "url" << currentUrl << "ts" << ts;
        });

        // Phase 2: JavaScript console capture (via performance monitoring JS logs captured as console.log)
        // Note: javaScriptConsoleMessage is protected in Qt6, so we capture logs via injected JS console.log

        connect(m_view, &QWebEngineView::loadFinished, this, [this](bool ok) {
            if (ok) {
                if (qEnvironmentVariableIsSet("WEREAD_START_BLANK")) {
                    qInfo() << "[INFO] startBlank mode: skip integrity/ready";
                    // 仍然抓一次帧，避免空白显示需要手动点击
                    scheduleBookCaptures();
                    return;
                }
                const qint64 now = QDateTime::currentMSecsSinceEpoch();
                qInfo() << "[TIMING] loadFinished url" << currentUrl << "ts" << now;
                m_firstFrameDone = false;
                m_reloadAttempts = 0;
                logUrlState(QStringLiteral("loadFinished"));
                sendBookState();
                if (isDedaoBook()) {
                    ensureDedaoDefaults();
                }
                
                // 智能延迟重试：仅在书籍页面且未调度过检查时，延迟检查一次（低功耗）
                if ((isWeReadBook() || isDedaoBook()) && !m_contentCheckScheduled) {
                    m_contentCheckScheduled = true;
                    m_contentRetryCount = 0;  // 重置计数器
                    qInfo() << "[RETRY] Scheduling content check after" << CONTENT_CHECK_DELAY_MS << "ms";
                    QTimer::singleShot(CONTENT_CHECK_DELAY_MS, this, [this]() {
                        checkContentAndRetryIfNeeded();
                        m_contentCheckScheduled = false;  // 允许下次页面加载时再次检查
                    });
                }
                
                // 恢复滚动位置（如果是恢复的会话）
                if (m_restoredScrollY > 0) {
                    QTimer::singleShot(500, this, [this]() {
                        if (m_view && m_view->page()) {
                            m_view->page()->runJavaScript(
                                QStringLiteral("window.scrollTo(0, %1)").arg(m_restoredScrollY)
                            );
                            qInfo() << "[SESSION] Restored scroll position:" << m_restoredScrollY;
                        }
                        m_restoredScrollY = 0;  // 清除，避免后续页面也恢复
                        m_isRestoringSession = false;  // 恢复完成
                    });
                }
                
                // 全屏刷新由智能刷新管理器统一处理，避免重复刷新
                // 智能刷新管理器会在 JS 监听器注入后通过 triggerLoadFinished() 触发

                // Phase 3: Inject performance monitoring JavaScript
                const QString perfMonitorJs = QStringLiteral(R"(
(function() {
    const logPerf = (event, data) => {
        console.log('[PERF_JS]', event, JSON.stringify(data), Date.now());
    };

    // Track DOM ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            logPerf('DOMContentLoaded', {readyState: document.readyState});
        });
    } else {
        logPerf('DOMContentLoaded_Already', {readyState: document.readyState});
    }

    // Track when WeRead content becomes visible
    const checkReady = setInterval(() => {
        const readerContent = document.querySelector('.renderTargetContent, #app, .app_content, .content');
        if (readerContent && readerContent.offsetHeight > 0) {
            logPerf('WeRead_Content_Found', {selector: readerContent.className, height: readerContent.offsetHeight});
            clearInterval(checkReady);
        }
    }, 100);

    // Track canvas operations
    const CanvasRenderingContext2D_original = CanvasRenderingContext2D.prototype.drawImage;
    if (CanvasRenderingContext2D_original) {
        CanvasRenderingContext2D.prototype.drawImage = function() {
            logPerf('Canvas_DrawImage', {args: arguments.length});
            return CanvasRenderingContext2D_original.apply(this, arguments);
        };
    }

    setTimeout(() => clearInterval(checkReady), 60000);
})();
)");
                m_view->page()->runJavaScript(perfMonitorJs);

                // Phase 4: 注入智能刷新 DOM 监听器（如果 urlChanged 中已注入则跳过）
                // 注意：JS 中已有 __SMART_REFRESH_INSTALLED__ 检查，不会重复注入
                const QString smartRefreshJs = QStringLiteral(R"(
(function() {
    if (window.__SMART_REFRESH_INSTALLED__) {
        // console.log('[SMART_REFRESH] Already installed from urlChanged, skipping loadFinished injection');
        return;
    }
    window.__SMART_REFRESH_INSTALLED__ = true;

    let pendingEvents = [];
    let burstMode = false, burstTimeout = null;
    let lastScrollTop = 0;

    // MutationObserver 检测 DOM 变化（优化：减少getBoundingClientRect调用，延迟处理区域计算）
    let pendingMutations = [];
    const processMutations = () => {
        if (pendingMutations.length === 0) return;
        const mutations = pendingMutations;
        pendingMutations = [];
        
        let score = 0;
        let regions = [];
        for (const m of mutations) {
            if (m.type === 'childList') {
                score += m.addedNodes.length * 10 + m.removedNodes.length * 10;
                // 优化：限制区域计算，只处理前5个节点，避免大量getBoundingClientRect调用影响点击响应
                const maxNodes = 5;
                let nodeCount = 0;
                for (const n of m.addedNodes) {
                    if (nodeCount >= maxNodes) break;
                    if (n.nodeType === 1 && n.getBoundingClientRect) {
                        try {
                            const r = n.getBoundingClientRect();
                            if (r.width > 0 && r.height > 0) {
                                regions.push({x:r.x|0, y:r.y|0, w:Math.ceil(r.width), h:Math.ceil(r.height)});
                                nodeCount++;
                            }
                        } catch(e) {}
                    }
                }
            } else if (m.type === 'attributes') score += 2;
            else if (m.type === 'characterData') score += 3;
        }

        if (score > 0) {
            pendingEvents.push({t:'dom', s:score, r:regions});
        }
    };
    
    const observer = new MutationObserver((mutations) => {
        // 批量收集mutations，延迟处理以减少对点击响应的影响
        pendingMutations.push(...mutations);
        // 使用requestIdleCallback延迟处理，如果浏览器不支持则使用setTimeout
        if (window.requestIdleCallback) {
            requestIdleCallback(processMutations, {timeout: 50});
        } else {
            setTimeout(processMutations, 0);
        }
    });

    // 延迟启动观察器，等待 body 准备就绪
    const startObserver = () => {
        if (document.body) {
            observer.observe(document.body, {childList:true, subtree:true, attributes:true, characterData:true});
        } else {
            setTimeout(startObserver, 100);
        }
    };
    startObserver();

    // 滚动监听（实时检测，节流 30ms 以降低频率但保持响应性）
    let scrollTimer = null;
    let lastReportTime = 0;
    window.addEventListener('scroll', () => {
        if (scrollTimer) return;
        scrollTimer = setTimeout(() => {
            const el = document.scrollingElement || document.documentElement;
            const delta = Math.abs(el.scrollTop - lastScrollTop);
            lastScrollTop = el.scrollTop;
            if (delta > 10) {
                pendingEvents.push({t:'scroll', d:delta});
                // 实时汇报：如果距离上次汇报超过 50ms，立即发送（不等待批量窗口）
                const now = Date.now();
                if (now - lastReportTime > 50) {
                    console.log('[REFRESH_EVENTS]' + JSON.stringify(pendingEvents));
                    pendingEvents = [];
                    lastReportTime = now;
                }
            }
            scrollTimer = null;
        }, 30);  // 降低节流时间到 30ms，提高响应性
    }, {passive:true});

    // 100ms 批量汇报（作为兜底，确保小事件也能被处理）
    // 书籍页面已禁用burstMode，所以移除!burstMode条件
    setInterval(() => {
        if (pendingEvents.length > 0) {
            console.log('[REFRESH_EVENTS]' + JSON.stringify(pendingEvents));
            pendingEvents = [];
            lastReportTime = Date.now();
        }
    }, 100);

    // console.log('[SMART_REFRESH] JS monitor installed (real-time scroll detection enabled)');
})();
)");
                m_view->page()->runJavaScript(smartRefreshJs);
                
                // Phase 5: 注入网络请求自动重试监听器（不重新加载页面）
                const QString autoRetryJs = QStringLiteral(R"(
(function() {
    if (window.__WR_AUTO_RETRY_INSTALLED__) return;
    window.__WR_AUTO_RETRY_INSTALLED__ = true;
    
    // 记录 API 调用（用于手动重试）
    const apiCalls = [];
    const originalFetch = window.fetch;
    
    // 拦截 fetch，自动重试失败的 /web/book/read 请求
    window.fetch = function(...args) {
        const url = args[0];
        if (typeof url === 'string' && url.includes('/web/book/read')) {
            // 记录API调用信息
            apiCalls.push({
                url: url,
                options: args[1] || {},
                timestamp: Date.now()
            });
            // 自动重试失败的请求（延迟2秒）
            return originalFetch.apply(this, args).catch(err => {
                console.log('[RETRY] Book read API failed, auto-retrying in 2s...', err);
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        originalFetch.apply(this, args)
                            .then(resolve)
                            .catch(reject);
                    }, 2000);
                });
            });
        }
        return originalFetch.apply(this, args);
    };
    
    // 拦截 XMLHttpRequest（如果页面使用 XHR）
    const originalXHROpen = XMLHttpRequest.prototype.open;
    const originalXHRSend = XMLHttpRequest.prototype.send;
    
    XMLHttpRequest.prototype.open = function(method, url, ...rest) {
        this._method = method;
        this._url = url;
        return originalXHROpen.apply(this, [method, url, ...rest]);
    };
    
    XMLHttpRequest.prototype.send = function(...args) {
        if (this._url && this._url.includes('/web/book/read')) {
            this.addEventListener('error', function() {
                console.log('[RETRY] XHR book read failed, auto-retrying...');
                setTimeout(() => {
                    const retryXHR = new XMLHttpRequest();
                    retryXHR.open(this._method || 'GET', this._url);
                    for (let key in this) {
                        if (key.startsWith('setRequestHeader')) {
                            try {
                                const headers = this.getAllResponseHeaders();
                                if (headers) {
                                    headers.split('\r\n').forEach(line => {
                                        const [name, value] = line.split(': ');
                                        if (name && value) retryXHR.setRequestHeader(name, value);
                                    });
                                }
                            } catch(e) {}
                        }
                    }
                    retryXHR.send(...args);
                }, 2000);
            });
        }
        return originalXHRSend.apply(this, args);
    };
    
    // 暴露手动重试函数（供C++代码调用）
    window.__WR_RETRY_BOOK_READ__ = function() {
        if (apiCalls.length > 0) {
            const lastCall = apiCalls[apiCalls.length - 1];
            console.log('[RETRY] Manual retry triggered, using recorded API call:', lastCall);
            return originalFetch(lastCall.url, lastCall.options).catch(err => {
                console.error('[RETRY] Manual retry failed:', err);
                throw err;
            });
        } else {
            // 如果没有记录，尝试通用方式
            const bookId = (window.location.href || '').match(/reader\/([a-zA-Z0-9]+)/)?.[1];
            if (bookId) {
                console.log('[RETRY] Manual retry triggered, using fallback method, bookId:', bookId);
                return originalFetch(`https://weread.qq.com/web/book/read?bookId=${bookId}`, {
                    credentials: 'include',
                    headers: {'Content-Type': 'application/json'}
                });
            }
            return Promise.reject('no_api_call_recorded_and_no_bookId');
        }
    };
    
    console.log('[RETRY] Auto-retry listener installed');
})();
)");
                m_view->page()->runJavaScript(autoRetryJs);
                qInfo() << "[SMART_REFRESH] Injected JS monitor script (loadFinished, may be skipped if already injected from urlChanged)";

                // 通知智能刷新管理器页面加载完成
                if (m_smartRefresh) {
                    m_smartRefresh->triggerLoadFinished();
                }

                // 总是抓一次帧，避免 ready 失败导致必须点击才显示
                scheduleBookCaptures();
                // 内容完整性检查：非书籍页走旧逻辑，书籍页单独做核心探针后再决定是否重载
                if (!isWeReadBook() && !isDedaoBook()) {
                    m_view->page()->runJavaScript(QStringLiteral(
                        "(() => {"
                        "  try {"
                        "    const bodyLen = (document.body && document.body.innerText) ? document.body.innerText.length : 0;"
                        "    const hasNuxt = !!(window.__NUXT__);"
                        "    return {bodyLen, hasNuxt, href: location.href||''};"
                        "  } catch(e) { return {error:String(e)}; }"
                        "})()"
                    ), [this, now](const QVariant &res){
                        const QVariantMap m = res.toMap();
                        const int bodyLen = m.value(QStringLiteral("bodyLen")).toInt();
                        const bool hasNuxt = m.value(QStringLiteral("hasNuxt")).toBool();
                        if (m_integrityReloads < 2 && (bodyLen < 200 && !hasNuxt)) {
                            m_integrityReloads++;
                            qWarning() << "[INTEGRITY] fail bodyLen" << bodyLen << "hasNuxt" << hasNuxt
                                       << "reload bypass cache attempt" << m_integrityReloads;
                            m_view->page()->triggerAction(QWebEnginePage::ReloadAndBypassCache);
                            m_lastReloadTs = now;
                            return;
                        }
                    });
                } else if (isWeReadBook()) {
                    // 书籍页：loadFinished 后早期自检正文/iframe，若全部为空且尚未重载过，尝试一次绕缓存重载
                    m_view->page()->runJavaScript(QStringLiteral(
                        "(() => {"
                        "  try {"
                        "    const bodyLen = (document.body && document.body.innerText) ? document.body.innerText.length : 0;"
                        "    const cont = document.querySelector('.renderTargetContent');"
                        "    const contLen = cont ? ((cont.innerText||'').length) : 0;"
                        "    let iframeText = 0;"
                        "    const frames = Array.from(document.querySelectorAll('iframe'));"
                        "    frames.forEach(f=>{"
                        "      try{ const d=f.contentDocument||f.contentWindow?.document; if(d&&d.body&&d.body.innerText){ iframeText += d.body.innerText.length; } }catch(_e){}"
                        "    });"
                        "    return {bodyLen, contLen, iframeText, frames: frames.length};"
                        "  } catch(e){ return {error:String(e)}; }"
                        "})()"
                    ), [this, now](const QVariant &res){
                        const auto m = res.toMap();
                        const int bodyLen = m.value(QStringLiteral("bodyLen")).toInt();
                        const int contLen = m.value(QStringLiteral("contLen")).toInt();
                        const int iframeText = m.value(QStringLiteral("iframeText")).toInt();
                        if (m_bookEarlyReloads < 1 && bodyLen == 0 && contLen == 0 && iframeText == 0) {
                            m_bookEarlyReloads++;
                            qWarning() << "[EARLY_RELOAD] book page empty, bypass cache attempt" << m_bookEarlyReloads
                                       << "frames" << m.value(QStringLiteral("frames")).toInt();
                            m_view->page()->triggerAction(QWebEnginePage::ReloadAndBypassCache);
                            m_lastReloadTs = now;
                            return;
                        }
                    });
                }
                const bool onWeReadHost = currentUrl.host().contains(QStringLiteral("weread.qq.com"), Qt::CaseInsensitive);

                // 阅读进度调试逻辑已移除以降低性能与耗电开销
                // 书籍页：即便未 ready，也先注入白底样式，确保白度判断可用
                if (isWeReadBook()) {
                    // 检查并设置默认字体大小和主题（如果未设置）
                    ensureDefaultBookSettings();
                    // applyBookEnhancements();  // 已关闭，不再强制应用主题增强

                    // 优化2: 在页面稳定后延迟加载被拦截的脚本 (WASM/支付/Worker)
                    // 延迟3秒后加载，使 loadFinished 不再等待这些脚本
                    QTimer::singleShot(3000, [this]() {
                        qInfo() << "[OPTIMIZATION] 延迟加载被拦截的脚本 (WASM/支付/Worker)";
                        m_view->page()->runJavaScript(QStringLiteral(
                            "(function() {"
                            "  // 创建脚本加载函数"
                            "  const loadScript = (src) => {"
                            "    return new Promise((resolve) => {"
                            "      const script = document.createElement('script');"
                            "      script.src = src;"
                            "      script.onload = () => { qInfo('[DEFER-LOADED]', src); resolve(); };"
                            "      script.onerror = () => { console.warn('[DEFER-FAILED]', src); resolve(); };"
                            "      document.body.appendChild(script);"
                            "    });"
                            "  };"
                            "  "
                            "  // 需要加载的脚本列表 (被拦截的脚本)"
                            "  const deferredScripts = ["
                            "    'https://midas.gtimg.cn/midas/minipay_v2/jsapi/cashier.js',"  // 支付
                            "    'https://cdn.weread.qq.com/web/wpa-1.0.5.js',"               // WASM
                            "  ];"
                            "  "
                            "  // 如果这些脚本尚未加载，则加载它们"
                            "  deferredScripts.forEach((src) => {"
                            "    const existingScript = Array.from(document.scripts).some(s => s.src === src);"
                            "    if (!existingScript) {"
                            "      loadScript(src).catch(e => console.error('[DEFER-ERROR]', src, e));"
                            "    }"
                            "  });"
                            "})();"
                        ), [](const QVariant &res) {
                            // JavaScript 执行完成
                        });
                    });
                }
                // 应用书籍页样式修复和视觉诊断（替代 Ready 机制）
                applyBookPageFixes();
            }
            else { qWarning() << "[WEREAD] Page load failed"; }
        });
        // 导航拦截：在真正发起请求前阻止误跳转到得到详情页
        connect(m_view->page(), &QWebEnginePage::navigationRequested, this,
                [this](QWebEngineNavigationRequest &request) {
            const QString target = request.url().toString();
            const bool targetDedaoDetail = target.contains(QStringLiteral("dedao.cn")) &&
                                           target.contains(QStringLiteral("/ebook/detail"));
            // 仅当当前就在 dedao 阅读页时才拦截详情跳转，其他页面允许正常打开详情
            if (isDedaoBook() && targetDedaoDetail && !m_allowDedaoDetailOnce) {
                qWarning() << "[NAV_GUARD] reject navigationRequested to dedao detail" << target;
                request.reject();
                return;
            }
            if (targetDedaoDetail && m_allowDedaoDetailOnce) {
                qInfo() << "[NAV_GUARD] allow dedao detail navigation (once)" << target;
                m_allowDedaoDetailOnce = false;
            }
        });

        connect(m_view, &QWebEngineView::urlChanged, this, [this](const QUrl &url){
            const QString oldUrl = currentUrl.toString();
            const QString newUrlStr = url.toString();
            currentUrl = url;
            const qint64 now = QDateTime::currentMSecsSinceEpoch();
            qInfo() << "[TIMING] urlChanged" << url << "ts" << now << "from" << oldUrl;
            
            // 重置内容重试状态（URL变化时）
            m_contentRetryCount = 0;
            m_contentCheckScheduled = false;
            m_lastContentCheckTime = 0;
            m_lastContentRetryTime = 0;
            m_contentFirstCheckFailed = false;
            
            // 记录最新的得到阅读页，便于回退
            if (newUrlStr.contains(QStringLiteral("dedao.cn")) &&
                newUrlStr.contains(QStringLiteral("/ebook/reader"))) {
                m_lastDedaoReaderUrl = newUrlStr;
            }
            
            // 延迟保存会话状态（避免频繁写入）
            if (!m_isRestoringSession) {
                QTimer::singleShot(2000, this, [this]() {
                    saveSessionState();
                });
            }
            // 在非阅读页允许进入 dedao 详情；仅在阅读页内时拦截
            const bool fromDedaoReader = oldUrl.contains(QStringLiteral("dedao.cn")) &&
                                         oldUrl.contains(QStringLiteral("/ebook/reader"));
            const bool toDedaoDetail = newUrlStr.contains(QStringLiteral("dedao.cn")) &&
                                       newUrlStr.contains(QStringLiteral("/ebook/detail"));
            if (fromDedaoReader && toDedaoDetail && !m_allowDedaoDetailOnce) {
                const QString fallback = !m_lastDedaoReaderUrl.isEmpty() ? m_lastDedaoReaderUrl : oldUrl;
                qWarning() << "[NAV_GUARD] block dedao detail urlChanged" << newUrlStr << "fallback" << fallback;
                if (m_view) {
                    m_view->stop();
                    m_view->setUrl(QUrl(fallback));
                }
                return;
            }
            if (toDedaoDetail && m_allowDedaoDetailOnce) {
                qInfo() << "[NAV_GUARD] allow dedao detail urlChanged once" << newUrlStr;
                m_allowDedaoDetailOnce = false;
            }
            logUrlState(QStringLiteral("urlChanged"));
            
            // 更新智能刷新管理器的书籍页面状态
            const bool isBook = isWeReadBook() || isDedaoBook();
            if (m_smartRefresh) {
                m_smartRefresh->setBookPage(isBook);
            }
            
            // 在urlChanged时设置cookie（如果是微信读书域名，包括首页和书籍页面）
            // 这样无论是首页还是书籍页面，cookie都会提前设置好
            const bool isWeReadDomain = newUrlStr.contains(QStringLiteral("weread.qq.com"));
            if (isWeReadDomain && m_view && m_view->page() && m_view->page()->profile()) {
                QNetworkCookie cookie(QByteArray("wr_theme"), QByteArray("white"));
                cookie.setDomain(".weread.qq.com");
                cookie.setPath("/");
                cookie.setExpirationDate(QDateTime::currentDateTime().addYears(1));
                m_view->page()->profile()->cookieStore()->setCookie(cookie, QUrl("https://weread.qq.com"));
                qInfo() << "[DEFAULT] Set theme cookie to white via CookieStore (urlChanged, url=" << newUrlStr << ")";
            }
            
            if (isBook) {
                m_bookEnterTs = now;
                qInfo() << "[TIMING] bookEnter ts" << now << "url" << url;
                // 进入书籍时立即启动抓帧循环，避免需手动触发
                scheduleBookCaptures();
                
                // 提前注入智能刷新 JS 监听器（从 urlChanged 开始，不等待 loadFinished）
                // 这样可以更早地捕获 DOM 变化和滚动事件
                const QString smartRefreshJs = QStringLiteral(R"(
(function() {
    if (window.__SMART_REFRESH_INSTALLED__) {
        // console.log('[SMART_REFRESH] Already installed, skipping');
        return;
    }
    window.__SMART_REFRESH_INSTALLED__ = true;

    let pendingEvents = [];
    let burstMode = false, burstTimeout = null;
    let lastScrollTop = 0;
    let lastReportTime = 0;

    // MutationObserver 检测 DOM 变化（优化：减少getBoundingClientRect调用，延迟处理区域计算）
    let pendingMutations = [];
    const processMutations = () => {
        if (pendingMutations.length === 0) return;
        const mutations = pendingMutations;
        pendingMutations = [];
        
        let score = 0;
        let regions = [];
        for (const m of mutations) {
            if (m.type === 'childList') {
                score += m.addedNodes.length * 10 + m.removedNodes.length * 10;
                // 优化：限制区域计算，只处理前5个节点，避免大量getBoundingClientRect调用影响点击响应
                const maxNodes = 5;
                let nodeCount = 0;
                for (const n of m.addedNodes) {
                    if (nodeCount >= maxNodes) break;
                    if (n.nodeType === 1 && n.getBoundingClientRect) {
                        try {
                            const r = n.getBoundingClientRect();
                            if (r.width > 0 && r.height > 0) {
                                regions.push({x:r.x|0, y:r.y|0, w:Math.ceil(r.width), h:Math.ceil(r.height)});
                                nodeCount++;
                            }
                        } catch(e) {}
                    }
                }
            } else if (m.type === 'attributes') score += 2;
            else if (m.type === 'characterData') score += 3;
        }

        if (score > 0) {
            pendingEvents.push({t:'dom', s:score, r:regions});
        }
    };
    
    const observer = new MutationObserver((mutations) => {
        // 批量收集mutations，延迟处理以减少对点击响应的影响
        pendingMutations.push(...mutations);
        // 使用requestIdleCallback延迟处理，如果浏览器不支持则使用setTimeout
        if (window.requestIdleCallback) {
            requestIdleCallback(processMutations, {timeout: 50});
        } else {
            setTimeout(processMutations, 0);
        }
    });

    // 延迟启动观察器，等待 body 准备就绪
    const startObserver = () => {
        if (document.body) {
            observer.observe(document.body, {childList:true, subtree:true, attributes:true, characterData:true});
        } else {
            setTimeout(startObserver, 100);
        }
    };
    startObserver();

    // 滚动监听（实时检测，节流 30ms 以降低频率但保持响应性）
    let scrollTimer = null;
    window.addEventListener('scroll', () => {
        if (scrollTimer) return;
        scrollTimer = setTimeout(() => {
            const el = document.scrollingElement || document.documentElement;
            const delta = Math.abs(el.scrollTop - lastScrollTop);
            lastScrollTop = el.scrollTop;
            if (delta > 10) {
                pendingEvents.push({t:'scroll', d:delta});
                // 实时汇报：如果距离上次汇报超过 50ms，立即发送（不等待批量窗口）
                const now = Date.now();
                if (now - lastReportTime > 50) {
                    console.log('[REFRESH_EVENTS]' + JSON.stringify(pendingEvents));
                    pendingEvents = [];
                    lastReportTime = now;
                }
            }
            scrollTimer = null;
        }, 30);  // 降低节流时间到 30ms，提高响应性
    }, {passive:true});

    // 100ms 批量汇报（作为兜底，确保小事件也能被处理）
    // 书籍页面已禁用burstMode，所以移除!burstMode条件
    setInterval(() => {
        if (pendingEvents.length > 0) {
            console.log('[REFRESH_EVENTS]' + JSON.stringify(pendingEvents));
            pendingEvents = [];
            lastReportTime = Date.now();
        }
    }, 100);

    // console.log('[SMART_REFRESH] JS monitor installed from urlChanged (real-time scroll detection enabled)');
})();
)");
                // 延迟 100ms 注入，确保页面开始加载
                QTimer::singleShot(100, this, [this, smartRefreshJs]() {
                    if (m_view && m_view->page()) {
                        m_view->page()->runJavaScript(smartRefreshJs);
                        qInfo() << "[SMART_REFRESH] Injected JS monitor script from urlChanged (early injection)";
                        
                        // 同时注入自动重试监听器
                        const QString autoRetryJs = QStringLiteral(R"(
(function() {
    if (window.__WR_AUTO_RETRY_INSTALLED__) return;
    window.__WR_AUTO_RETRY_INSTALLED__ = true;
    
    // 记录 API 调用（用于手动重试）
    const apiCalls = [];
    const originalFetch = window.fetch;
    
    // 拦截 fetch，自动重试失败的 /web/book/read 请求
    window.fetch = function(...args) {
        const url = args[0];
        if (typeof url === 'string' && url.includes('/web/book/read')) {
            // 记录API调用信息
            apiCalls.push({
                url: url,
                options: args[1] || {},
                timestamp: Date.now()
            });
            // 自动重试失败的请求（延迟2秒）
            return originalFetch.apply(this, args).catch(err => {
                console.log('[RETRY] Book read API failed, auto-retrying in 2s...', err);
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        originalFetch.apply(this, args)
                            .then(resolve)
                            .catch(reject);
                    }, 2000);
                });
            });
        }
        return originalFetch.apply(this, args);
    };
    
    // 拦截 XMLHttpRequest（如果页面使用 XHR）
    const originalXHROpen = XMLHttpRequest.prototype.open;
    const originalXHRSend = XMLHttpRequest.prototype.send;
    
    XMLHttpRequest.prototype.open = function(method, url, ...rest) {
        this._method = method;
        this._url = url;
        return originalXHROpen.apply(this, [method, url, ...rest]);
    };
    
    XMLHttpRequest.prototype.send = function(...args) {
        if (this._url && this._url.includes('/web/book/read')) {
            this.addEventListener('error', function() {
                console.log('[RETRY] XHR book read failed, auto-retrying...');
                setTimeout(() => {
                    const retryXHR = new XMLHttpRequest();
                    retryXHR.open(this._method || 'GET', this._url);
                    for (let key in this) {
                        if (key.startsWith('setRequestHeader')) {
                            try {
                                const headers = this.getAllResponseHeaders();
                                if (headers) {
                                    headers.split('\r\n').forEach(line => {
                                        const [name, value] = line.split(': ');
                                        if (name && value) retryXHR.setRequestHeader(name, value);
                                    });
                                }
                            } catch(e) {}
                        }
                    }
                    retryXHR.send(...args);
                }, 2000);
            });
        }
        return originalXHRSend.apply(this, args);
    };
    
    // 暴露手动重试函数（供C++代码调用）
    window.__WR_RETRY_BOOK_READ__ = function() {
        if (apiCalls.length > 0) {
            const lastCall = apiCalls[apiCalls.length - 1];
            console.log('[RETRY] Manual retry triggered, using recorded API call:', lastCall);
            return originalFetch(lastCall.url, lastCall.options).catch(err => {
                console.error('[RETRY] Manual retry failed:', err);
                throw err;
            });
        } else {
            // 如果没有记录，尝试通用方式
            const bookId = (window.location.href || '').match(/reader\/([a-zA-Z0-9]+)/)?.[1];
            if (bookId) {
                console.log('[RETRY] Manual retry triggered, using fallback method, bookId:', bookId);
                return originalFetch(`https://weread.qq.com/web/book/read?bookId=${bookId}`, {
                    credentials: 'include',
                    headers: {'Content-Type': 'application/json'}
                });
            }
            return Promise.reject('no_api_call_recorded_and_no_bookId');
        }
    };
    
    console.log('[RETRY] Auto-retry listener installed (from urlChanged)');
})();
)");
                        m_view->page()->runJavaScript(autoRetryJs);
                    }
                });
            }
            updateUserAgentForUrl(url);
            sendBookState();
        });
        // 允许通过环境变量加载本地保存的 wr.html 以验证解析差异
        const QByteArray localHtmlEnv = qgetenv("WEREAD_LOCAL_HTML");
        const bool startBlank = qEnvironmentVariableIsSet("WEREAD_START_BLANK");
        if (startBlank) {
            qInfo() << "[WEREAD] Starting with about:blank (WEREAD_START_BLANK set)";
            m_view->setHtml(QStringLiteral("<!DOCTYPE html><html><body>blank start</body></html>"),
                            QUrl(QStringLiteral("about:blank")));
        } else if (!localHtmlEnv.isEmpty()) {
            const QUrl localUrl = QUrl::fromLocalFile(QString::fromLocal8Bit(localHtmlEnv));
            qInfo() << "[WEREAD] Loading local HTML for diagnostic:" << localUrl;
            m_view->load(localUrl);
        } else {
            m_view->load(url);
        }

        // 智能刷新：空闲清理定时器（500ms 无操作后检查是否需要 GC16 全刷清理残影）
        m_idleCleanupTimer = new QTimer(this);
        m_idleCleanupTimer->setSingleShot(true);
        m_idleCleanupTimer->setInterval(500);
        connect(m_idleCleanupTimer, &QTimer::timeout, this, [this]() {
            if (m_fbRef && m_fbRef->needsCleanup()) {
                qInfo() << "[EINK] Idle cleanup triggered: partial=" << m_fbRef->partialCount()
                        << "a2=" << m_fbRef->a2Count();
                m_fbRef->refreshCleanup(width(), height());
            }
        });
        
        // 定期保存会话状态：每分钟自动保存一次（用于书籍页面等 URL 不变的情况）
        m_sessionSaveTimer = new QTimer(this);
        m_sessionSaveTimer->setSingleShot(false); // 重复触发
        m_sessionSaveTimer->setInterval(60000);    // 60秒 = 1分钟
        connect(m_sessionSaveTimer, &QTimer::timeout, this, &WereadBrowser::saveSessionState);
        m_sessionSaveTimer->start();
        qInfo() << "[SESSION] Auto-save timer started (interval: 60s)";

        // Quick menu overlay (hidden by default)
        // menu overlay placed on top of the webview so it is captured in grab()
        m_menu = new QFrame(m_view);
        m_menu->setObjectName("weread_menu_overlay");  // 设置唯一标识，用于事件过滤器识别
        m_menu->setStyleSheet("QFrame { background: #ffffff; border: 0px solid transparent; border-radius: 12px; }"
                              "QPushButton { color: #000000; background: #e6e6e6; font-size: 22px; font-weight: 700; padding: 14px 18px; border-radius: 10px; }"
                              "QPushButton:pressed { background: #cfcfcf; }");
        auto *layout = new QHBoxLayout(m_menu);
        layout->setContentsMargins(16, 12, 16, 12);
        layout->setSpacing(12);
        auto addBtn = [&](const QString &text, const std::function<void()> &fn){
            auto *b = new QPushButton(text, m_menu);
            layout->addWidget(b);
            connect(b, &QPushButton::clicked, this, [text, fn](){
                qInfo() << "[MENU_BUTTON] Button clicked:" << text;
                fn();
            });
            return b;
        };
        addBtn(QStringLiteral("字体切换"), [this](){ toggleTheme(); }); // 暂时改为主题切换，便于在页面侧写入 cookies/LS
        addBtn(QStringLiteral("微信读书/得到"), [this](){ toggleService(); });
        auto *fontPlus = addBtn(QStringLiteral("字体 +"), [this](){ adjustFont(true); });
        if (fontPlus) {
            fontPlus->setStyleSheet("QPushButton { font-size:26px; font-weight:600; padding: 14px 18px; }"
                                    "QPushButton { letter-spacing: 2px; }");
        }
        auto *fontMinus = addBtn(QStringLiteral("字体 -"), [this](){ adjustFont(false); });
        if (fontMinus) {
            fontMinus->setStyleSheet("QPushButton { font-size:26px; font-weight:600; padding: 14px 18px; }"
                                     "QPushButton { letter-spacing: 2px; }");
        }
        m_uaButton = addBtn(QStringLiteral("UA"), [this](){ cycleUserAgentMode(); });
        // 根据当前 UA 推断模式，初始化按钮文案
        m_uaMode = detectUaMode(m_profile->httpUserAgent());
        updateUaButtonText(m_uaMode);
        m_menu->setVisible(false);
        m_menu->setFixedHeight(90);
        // initial size/position; will be updated in showMenu()
        m_menu->setGeometry(20, 20, 600, 90);
        // Allow menu buttons to receive clicks - 设置属性确保菜单能拦截事件
        m_menu->setAttribute(Qt::WA_TransparentForMouseEvents, false);  // 确保菜单能接收鼠标事件
        m_menu->setAttribute(Qt::WA_NoMouseReplay, false);  // 允许鼠标事件重放
        m_menu->raise();  // 确保菜单在最上层
        m_menuTimer.setInterval(5000);
        m_menuTimer.setSingleShot(true);
        connect(&m_menuTimer, &QTimer::timeout, this, [this](){ m_menu->hide(); });
        // Disable periodic heartbeat captures to avoid重复抓帧
        m_heartbeatTimer.setInterval(0);

        // listen for state requests on 45457 and respond with current state
        const QHostAddress bindAddr(QStringLiteral("127.0.0.1"));
        const bool ok = m_stateResponder.bind(bindAddr, 45457,
                                              QUdpSocket::ShareAddress | QUdpSocket::ReuseAddressHint);
        qInfo() << "[STATE] responder bind" << ok << "addr" << bindAddr.toString() << "port" << 45457;
        connect(&m_stateResponder, &QUdpSocket::readyRead, this, &WereadBrowser::handleStateRequest);

        // 暂停所有注入脚本（探针/错误钩子），验证是否为注入引起的解析问题
    }
private slots:
    void captureFrame() { /* 一体化模式下不再抓帧到 SHM，留空 */ }
    void onExitClicked() { /* removed */ }
public:
    void injectMouse(Qt::MouseButton btn, QEvent::Type type, const QPointF& pos) {
        if (!m_view) return;
        const qreal z = m_view->zoomFactor();
        const QPointF pagePos = (z != 0.0) ? (pos / z) : pos;
        QMouseEvent *ev = new QMouseEvent(type, pagePos, btn, btn, Qt::NoModifier);
        QCoreApplication::postEvent(m_view, ev);
    }
    // 获取内部 WebEngineView，用于安装事件过滤器（如 GestureFilter）
    QWebEngineView* view() const { return m_view; }
    void scrollByJs(int dy) {
        if (!m_view || !m_view->page()) return;
        m_view->page()->runJavaScript(QStringLiteral("window.scrollBy(0,%1);").arg(dy));
        qInfo() << "[TOUCH] js scroll" << dy;
        scheduleBookCaptures();
        // 使用智能刷新管理器处理滚动刷新
        if (m_smartRefresh) {
            SmartRefreshManager::RefreshEvent e;
            e.type = SmartRefreshManager::RefreshEvent::SCROLL;
            e.scrollDelta = qAbs(dy);
            QTimer::singleShot(100, this, [this, e]() {
                if (m_smartRefresh) m_smartRefresh->pushEvent(e);
            });
        } else if (m_fbRef) {
            // 后备：直接调用 FbRefreshHelper
            QTimer::singleShot(100, this, [this]() {
                if (m_fbRef) m_fbRef->refreshScroll(width(), height());
            });
        }
        // 重置空闲清理定时器
        if (m_idleCleanupTimer) m_idleCleanupTimer->start();
    }
    int pageStep() const {
        if (m_view) return static_cast<int>(m_view->height() * 0.3);
        return 400;
    }
    void hittestJs(const QPointF& pos) {
        if (!m_view || !m_view->page()) return;
        // Fix coordinate scaling: divide by zoomFactor to get page coordinates
        const qreal zoomFactor = m_view->zoomFactor();
        const QPointF pagePos = pos / zoomFactor;
        qInfo() << "[HITTEST] Screen pos:" << pos << "Page pos:" << pagePos << "Zoom:" << zoomFactor;
        const QString script = QStringLiteral(
            "var x=%1,y=%2;"
            "function tag(e){if(!e) return 'null';"
            " var t=e.tagName; if(e.id) t+='#'+e.id;"
            " if(e.className) t+='.'+e.className; return t;}"
            "var el=document.elementFromPoint(x,y);"
            "var res='';"
            "if(!el){res='null';}"
            "else if(el.tagName==='IFRAME'){"
            "  res='iframe';"
            "  var r=el.getBoundingClientRect();"
            "  try{"
            "    var d=el.contentDocument||el.contentWindow.document;"
            "    if(d){"
            "      var inner=d.elementFromPoint(x-r.left,y-r.top);"
            "      res+='->'+tag(inner);"
            "      if(inner && inner.click) inner.click();"
            "    }"
            "  }catch(e){ res+='->blocked'; }"
            "}"
            "else {"
            "  var cls=(el.className||'')+'';"
            "  var txt=(el.innerText||'').trim();"
            "  res=tag(el)+\"|\"+txt;"
            "  if(!(cls.includes('btn focus-btn') && location.href.includes('/ebook/reader/'))){"
            "    if(el.click) el.click();"
            "  } else {"
            "    res+='|blocked';"
            "  }"
            "}"
            "res;"
        ).arg(pagePos.x()).arg(pagePos.y());
        m_view->page()->runJavaScript(script, [](const QVariant &v){
            qInfo() << "[HITTEST]" << v.toString();
        });
    }
    void injectWheel(const QPointF& pos, int dy) {
        if (!m_view) return;
        // Map accumulated pixel drag to wheel: 120 units per step is the Qt convention.
        // Positive dy should scroll down (natural touch).
        const int angleStep = dy; // use pixel distance as angle seed
        QPoint pixelDelta(0, -dy);                      // natural: drag down -> scroll down
        QPoint angleDelta(0, -angleStep);               // same sign as pixelDelta
        auto *ev = new QWheelEvent(pos, m_view->mapToGlobal(pos.toPoint()),
                                   pixelDelta, angleDelta, Qt::NoButton,
                                   Qt::NoModifier, Qt::ScrollUpdate, false);
        QCoreApplication::postEvent(m_view, ev);
        qInfo() << "[TOUCH] wheel dy" << dy << "pos" << pos;
    }
    void goNextPage() {
        qInfo() << "[PAGER] goNextPage() called";
        if (!m_view) {
            qWarning() << "[PAGER] goNextPage() aborted: m_view is null";
            return;
        }
        if (!m_view->page()) {
            qWarning() << "[PAGER] goNextPage() aborted: m_view->page() is null";
            return;
        }
        const qint64 now = QDateTime::currentMSecsSinceEpoch();
        
        // 如果已经有翻页在进行，检查是否应该取消
        if (m_navigating) {
            const qint64 elapsed = now - m_navStartTime;
            if (elapsed > 500) {  // 如果第1次点击超过500ms还没完成
                qWarning() << "[PAGER] Previous navigation taking too long (" << elapsed 
                           << "ms), cancelling and processing new click. Old seq:" 
                           << m_pendingNavSeq << "New seq:" << (m_navSequence + 1);
                
                // 取消旧的超时定时器
                if (m_navTimeoutTimer) {
                    m_navTimeoutTimer->stop();
                    m_navTimeoutTimer->disconnect();  // 断开所有连接，避免回调执行
                    m_navTimeoutTimer->deleteLater();
                    m_navTimeoutTimer = nullptr;
                }
                
                // 标记旧序列为已取消（回调中会检查）
                m_pendingNavSeq = 0;  // 设置为0表示已取消
                
                // 继续处理新的点击（不return）
            } else {
                // 如果第1次点击还在500ms内，跳过第2次
                qInfo() << "[PAGER] skip next: navigating (m_navigating=true, elapsed=" 
                        << elapsed << "ms)";
                return;
            }
        }
        
        const int currentSeq = ++m_navSequence;
        m_navigating = true;
        m_navStartTime = now;  // 记录开始时间
        m_pendingNavSeq = currentSeq;  // 记录待处理的序列号
        cancelPendingCaptures();  // 取消旧页面的待执行抓帧
        m_firstFrameDone = false;
        m_reloadAttempts = 0;
        const qint64 tsStart = QDateTime::currentMSecsSinceEpoch();
        qInfo() << "[PAGER] next start ts" << tsStart << "seq" << currentSeq << "url" << m_view->url();
        
        // 通知智能刷新管理器：点击操作，重置score阈值（仅在书籍页面生效）
        if (m_smartRefresh) {
            m_smartRefresh->resetScoreThreshold();
        }
        
        if (isDedaoBook()) {
            dedaoScroll(true);
            return;
        }
        if (isWeReadBook()) {
            const bool isKindleUA = m_currentUA.contains(QStringLiteral("Kindle"), Qt::CaseInsensitive)
                                    || m_uaWeReadBook.contains(QStringLiteral("Kindle"), Qt::CaseInsensitive)
                                    || m_uaMode.compare(QStringLiteral("kindle"), Qt::CaseInsensitive) == 0;
            if (m_weReadBookMode == QStringLiteral("mobile") && !isKindleUA) {
                logPageProbe(QStringLiteral("[PAGER] weRead next probe (mobile)"));
                weReadScroll(true);
                return;
            }
            qInfo() << "[PAGER] weRead kindle/web mode: using pager buttons";
        }
        
        // 使用成员变量的定时器，可以取消
        if (m_navTimeoutTimer) {
            m_navTimeoutTimer->stop();
            m_navTimeoutTimer->disconnect();  // 断开所有连接，避免回调执行
            m_navTimeoutTimer->deleteLater();
            m_navTimeoutTimer = nullptr;  // 立即设置为nullptr，避免重复使用
        }
        m_navTimeoutTimer = new QTimer(this);
        m_navTimeoutTimer->setSingleShot(true);
        m_navTimeoutTimer->setInterval(1000);
        connect(m_navTimeoutTimer, &QTimer::timeout, this, [this, currentSeq](){
            if (m_navigating && m_navSequence == currentSeq && m_pendingNavSeq == currentSeq) {
                m_navigating = false;
                m_pendingNavSeq = 0;
                qWarning() << "[PAGER] Force unlock next (timeout 1000ms) seq" << currentSeq;
            }
        });
        m_navTimeoutTimer->start();
        const QString js = QStringLiteral(
            "(function(){"
            "  var btn=document.querySelector('.renderTarget_pager_button_right');"
            "  if(!btn){console.log('[PAGER_JS] button not found');return false;}"
            "  if(!btn.click){console.log('[PAGER_JS] button has no click method');return false;}"
            "  var jsStartTime = new Date().getTime();"
            "  console.log('[PAGER_JS] button found, clicking...', jsStartTime);"
            "  var clickStart = new Date().getTime();"
            "  btn.click();"
            "  var clickEnd = new Date().getTime();"
            "  console.log('[PAGER_JS] button clicked, duration', clickEnd - clickStart, 'ms');"
            "  return true;"
            "})()"
        );
        const qint64 jsCallTime = QDateTime::currentMSecsSinceEpoch();
        m_view->page()->runJavaScript(js, [this, currentSeq, jsCallTime](const QVariant &res){
            // 检查是否被取消
            if (m_pendingNavSeq != currentSeq) {
                qInfo() << "[PAGER] next callback cancelled (seq mismatch: pending=" 
                        << m_pendingNavSeq << "current=" << currentSeq << ")";
                // 停止定时器（如果存在且属于这个序列）
                if (m_navTimeoutTimer) {
                    m_navTimeoutTimer->stop();
                }
                return;  // 直接返回，不处理
            }
            
            const qint64 jsResultTime = QDateTime::currentMSecsSinceEpoch();
            const qint64 jsDelay = jsResultTime - jsCallTime;
            const bool ok = res.toBool();
            qInfo() << "[PAGER] next click result" << ok << "seq" << currentSeq 
                    << "JS execution delay" << jsDelay << "ms"
                    << "callTime" << jsCallTime << "resultTime" << jsResultTime;
            if (!ok) {
                if (isWeReadBook()) {
                    // 微信书籍页面：按钮未找到时，注入普通点击事件给webengine处理
                    qWarning() << "[PAGER] next button click failed, injecting mouse click to webengine";
                    const QPointF centerPos(m_view ? m_view->width() / 2.0 : 477.0, 
                                            m_view ? m_view->height() / 2.0 : 848.0);
                    injectMouse(Qt::LeftButton, QEvent::MouseButtonPress, centerPos);
                    QTimer::singleShot(50, this, [this, centerPos]() {
                        injectMouse(Qt::LeftButton, QEvent::MouseButtonRelease, centerPos);
                    });
                    qInfo() << "[PAGER] injected mouse click at center" << centerPos;
                } else {
                    // 非微信书籍页面：使用scrollBy作为fallback
                    qWarning() << "[PAGER] next button click failed, using fallback scrollBy";
                    const int fallback = pageStep();
                    qInfo() << "[PAGER] next fallback scrollBy" << fallback;
                    scrollByJs(fallback);
                }
            } else {
                qInfo() << "[PAGER] next button click succeeded";
            }
            // 优化：延迟执行keepAliveNearChapterEnd，避免影响点击响应
            QTimer::singleShot(200, this, [this]() { keepAliveNearChapterEnd(); });
            if (m_navSequence == currentSeq && m_pendingNavSeq == currentSeq) {
                m_navigating = false;
                m_pendingNavSeq = 0;
                
                // 停止超时定时器
                if (m_navTimeoutTimer) {
                    m_navTimeoutTimer->stop();
                }
            } else {
                qInfo() << "[PAGER] next callback ignored, seq mismatch (navSeq=" 
                        << m_navSequence << "pending=" << m_pendingNavSeq << "current=" << currentSeq << ")";
            }
            if (isWeReadBook() && m_weReadBookMode == QStringLiteral("mobile")) alignWeReadPagination();
        });
    }
    void goPrevPage() {
        qInfo() << "[PAGER] goPrevPage() called";
        if (!m_view) {
            qWarning() << "[PAGER] goPrevPage() aborted: m_view is null";
            return;
        }
        if (!m_view->page()) {
            qWarning() << "[PAGER] goPrevPage() aborted: m_view->page() is null";
            return;
        }
        const qint64 now = QDateTime::currentMSecsSinceEpoch();
        
        // 如果已经有翻页在进行，检查是否应该取消
        if (m_navigating) {
            const qint64 elapsed = now - m_navStartTime;
            if (elapsed > 500) {  // 如果第1次点击超过500ms还没完成
                qWarning() << "[PAGER] Previous navigation taking too long (" << elapsed 
                           << "ms), cancelling and processing new prev click. Old seq:" 
                           << m_pendingNavSeq << "New seq:" << (m_navSequence + 1);
                
                // 取消旧的超时定时器
                if (m_navTimeoutTimer) {
                    m_navTimeoutTimer->stop();
                    m_navTimeoutTimer->disconnect();  // 断开所有连接，避免回调执行
                    m_navTimeoutTimer->deleteLater();
                    m_navTimeoutTimer = nullptr;
                }
                
                // 标记旧序列为已取消（回调中会检查）
                m_pendingNavSeq = 0;  // 设置为0表示已取消
                
                // 继续处理新的点击（不return）
            } else {
                // 如果第1次点击还在500ms内，跳过第2次
                qInfo() << "[PAGER] skip prev: navigating (m_navigating=true, elapsed=" 
                        << elapsed << "ms)";
                return;
            }
        }
        
        const int currentSeq = ++m_navSequence;
        m_navigating = true;
        m_navStartTime = now;  // 记录开始时间
        m_pendingNavSeq = currentSeq;  // 记录待处理的序列号
        cancelPendingCaptures();  // 取消旧页面的待执行抓帧
        m_firstFrameDone = false;
        m_reloadAttempts = 0;
        const qint64 tsStart = QDateTime::currentMSecsSinceEpoch();
        qInfo() << "[PAGER] prev start ts" << tsStart << "seq" << currentSeq << "url" << m_view->url();
        
        // 通知智能刷新管理器：点击操作，重置score阈值（仅在书籍页面生效）
        if (m_smartRefresh) {
            m_smartRefresh->resetScoreThreshold();
        }
        
        if (isDedaoBook()) {
            dedaoScroll(false);
            return;
        }
        if (isWeReadBook()) {
            const bool isKindleUA = m_currentUA.contains(QStringLiteral("Kindle"), Qt::CaseInsensitive)
                                    || m_uaWeReadBook.contains(QStringLiteral("Kindle"), Qt::CaseInsensitive)
                                    || m_uaMode.compare(QStringLiteral("kindle"), Qt::CaseInsensitive) == 0;
            if (m_weReadBookMode == QStringLiteral("mobile") && !isKindleUA) {
                logPageProbe(QStringLiteral("[PAGER] weRead prev probe (mobile)"));
                weReadScroll(false);
                return;
            }
            qInfo() << "[PAGER] weRead kindle/web mode: using pager buttons";
        }
        
        // 使用成员变量的定时器，可以取消
        if (m_navTimeoutTimer) {
            m_navTimeoutTimer->stop();
            m_navTimeoutTimer->disconnect();  // 断开所有连接，避免回调执行
            m_navTimeoutTimer->deleteLater();
            m_navTimeoutTimer = nullptr;  // 立即设置为nullptr，避免重复使用
        }
        m_navTimeoutTimer = new QTimer(this);
        m_navTimeoutTimer->setSingleShot(true);
        m_navTimeoutTimer->setInterval(1000);
        connect(m_navTimeoutTimer, &QTimer::timeout, this, [this, currentSeq](){
            if (m_navigating && m_navSequence == currentSeq && m_pendingNavSeq == currentSeq) {
                m_navigating = false;
                m_pendingNavSeq = 0;
                qWarning() << "[PAGER] Force unlock prev (timeout 1000ms) seq" << currentSeq;
            }
        });
        m_navTimeoutTimer->start();
        const QString js = QStringLiteral(
            "(function(){"
            "  var btn=document.querySelector('.renderTarget_pager_button');"
            "  if(!btn){console.log('[PAGER_JS] button not found');return false;}"
            "  if(!btn.click){console.log('[PAGER_JS] button has no click method');return false;}"
            "  console.log('[PAGER_JS] button found, clicking...');"
            "  btn.click();"
            "  return true;"
            "})()"
        );
        qInfo() << "[PAGER] executing JS to click prev button";
        m_view->page()->runJavaScript(js, [this, currentSeq](const QVariant &res){
            // 检查是否被取消
            if (m_pendingNavSeq != currentSeq) {
                qInfo() << "[PAGER] prev callback cancelled (seq mismatch: pending=" 
                        << m_pendingNavSeq << "current=" << currentSeq << ")";
                // 停止定时器（如果存在且属于这个序列）
                if (m_navTimeoutTimer) {
                    m_navTimeoutTimer->stop();
                }
                return;  // 直接返回，不处理
            }
            
            const bool ok = res.toBool();
            qInfo() << "[PAGER] prev click result" << ok << "seq" << currentSeq;
            if (!ok) {
                if (isWeReadBook()) {
                    // 微信书籍页面：按钮未找到时，注入普通点击事件给webengine处理
                    qWarning() << "[PAGER] prev button click failed, injecting mouse click to webengine";
                    const QPointF centerPos(m_view ? m_view->width() / 2.0 : 477.0, 
                                            m_view ? m_view->height() / 2.0 : 848.0);
                    injectMouse(Qt::LeftButton, QEvent::MouseButtonPress, centerPos);
                    QTimer::singleShot(50, this, [this, centerPos]() {
                        injectMouse(Qt::LeftButton, QEvent::MouseButtonRelease, centerPos);
                    });
                    qInfo() << "[PAGER] injected mouse click at center" << centerPos;
                } else {
                    // 非微信书籍页面：使用scrollBy作为fallback
                    qWarning() << "[PAGER] prev button click failed, using fallback scrollBy";
                    const int fallback = -pageStep();
                    qInfo() << "[PAGER] prev fallback scrollBy" << fallback;
                    scrollByJs(fallback);
                }
            } else {
                qInfo() << "[PAGER] prev button click succeeded";
            }
            // 优化：延迟执行keepAliveNearChapterEnd，避免影响点击响应
            QTimer::singleShot(200, this, [this]() { keepAliveNearChapterEnd(); });
            if (m_navSequence == currentSeq && m_pendingNavSeq == currentSeq) {
                m_navigating = false;
                m_pendingNavSeq = 0;
                
                // 停止超时定时器
                if (m_navTimeoutTimer) {
                    m_navTimeoutTimer->stop();
                }
            } else {
                qInfo() << "[PAGER] prev callback ignored, seq mismatch (navSeq=" 
                        << m_navSequence << "pending=" << m_pendingNavSeq << "current=" << currentSeq << ")";
            }
            if (isWeReadBook() && m_weReadBookMode == QStringLiteral("mobile")) alignWeReadPagination();
        });
    }
    void openCatalog() {
        if (!m_view || !m_view->page()) return;
        qInfo() << "[MENU] catalog click skipped (buttons hidden)";
    }
    void adjustFont(bool increase) {
        qInfo() << "[MENU] adjustFont called, increase=" << increase;
        if (!m_view || !m_view->page()) return;
        cancelPendingCaptures();  // 取消旧的待执行抓帧
        m_firstFrameDone = false;
        m_reloadAttempts = 0;
        if (isDedaoBook()) {
            const QString openSettingJs = QStringLiteral(
                "(() => {"
                "  const settingBtn = document.querySelector('.reader-tool-button.tool-margin-right');"
                "  if (settingBtn && typeof settingBtn.click === 'function') {"
                "    settingBtn.click();"
                "    return {ok:true, action:'open-setting'};"
                "  }"
                "  return {ok:false, reason:'no-setting-btn'};"
                "})();"
            );
            m_view->page()->runJavaScript(openSettingJs, [this, increase](const QVariant &res){
                qInfo() << "[MENU] open setting panel" << res;
                QTimer::singleShot(300, this, [this, increase](){
                    const QString adjustFontJs = QStringLiteral(
                        "(() => {"
                        "  const inc=%1;"
                        "  const buttons = Array.from(document.querySelectorAll('.set-tool-box-change-font button'));"
                        "  if (buttons.length === 0) return {ok:false, reason:'no-font-buttons'};"
                        "  const btn = inc>0 ? buttons[buttons.length-1] : buttons[0];"
                        "  if (btn && btn.click) {"
                        "    btn.click();"
                        "    const fontNum = document.querySelector('.set-tool-box-font-number');"
                        "    const num = fontNum ? fontNum.textContent.trim() : '';"
                        "    return {ok:true, mode:'dedao', inc, font:num};"
                        "  }"
                        "  return {ok:false, reason:'btn-no-click', mode:'dedao'};"
                        "})();"
                    ).arg(increase ? 1 : -1);
                    m_view->page()->runJavaScript(adjustFontJs, [this](const QVariant &res){
                        qInfo() << "[MENU] font step (dedao)" << res;
                    });
                });
            });
            return;
        }
        const QString js = QStringLiteral(
            "(() => {"
            "  const delta=%1;"
            "  let setting={};"
            "  try{ setting=JSON.parse(localStorage.getItem('wrLocalSetting')||'{}'); }catch(e){ setting={}; }"
            "  const before=setting.fontSizeLevel||3;"
            "  const after=Math.max(1, Math.min(7, before+delta));"
            "  setting.fontSizeLevel=after;"
            "  if(!setting.fontFamily) setting.fontFamily='wr_default_font';"
            "  try{ localStorage.setItem('wrLocalSetting', JSON.stringify(setting)); }catch(e){}"
            "  setTimeout(()=>location.reload(),50);"
            "  return {ok:true,before,after};"
            "})();").arg(increase ? 1 : -1);
        m_view->page()->runJavaScript(js, [this](const QVariant &res){
            qInfo() << "[MENU] font step result" << res;
        });
    }
    void toggleTheme() {
        qInfo() << "[MENU] toggleTheme called";
        if (!m_view || !m_view->page()) return;
        cancelPendingCaptures();  // 取消旧的待执行抓帧
        m_firstFrameDone = false;
        m_reloadAttempts = 0;
        if (isDedaoBook()) {
            const QString openSettingJs = QStringLiteral(
                "(() => {"
                "  const settingBtn = document.querySelector('.reader-tool-button.tool-margin-right');"
                "  if (settingBtn && typeof settingBtn.click === 'function') {"
                "    settingBtn.click();"
                "    return {ok:true, action:'open-setting'};"
                "  }"
                "  return {ok:false, reason:'no-setting-btn'};"
                "})();"
            );
            m_view->page()->runJavaScript(openSettingJs, [this](const QVariant &res){
                qInfo() << "[MENU] open setting panel for theme" << res;
                QTimer::singleShot(300, this, [this](){
                    const QString toggleThemeJs = QStringLiteral(
                        "(() => {"
                        "  const list = Array.from(document.querySelectorAll('.tool-box-theme-group .reader-tool-theme-button'));"
                        "  if (list.length === 0) return {ok:false, reason:'no-theme-buttons'};"
                        "  const curIdx = list.findIndex(el => el.classList.contains('reader-tool-theme-button-selected'));"
                        "  const nextIdx = list.length ? ((curIdx>=0 ? (curIdx+1)%list.length : 0)) : -1;"
                        "  if (nextIdx>=0 && list[nextIdx] && list[nextIdx].click) {"
                        "    list[nextIdx].click();"
                        "    const sel = list[nextIdx].querySelector('.reader-tool-theme-button-text');"
                        "    const text = sel ? sel.textContent.trim() : '';"
                        "    return {ok:true, cur:curIdx, next:nextIdx, count:list.length, mode:'dedao', text};"
                        "  }"
                        "  return {ok:false, reason:'no-theme-btn', count:list.length, mode:'dedao'};"
                        "})();"
                    );
                    m_view->page()->runJavaScript(toggleThemeJs, [this](const QVariant &res){
                        qInfo() << "[MENU] theme toggle (dedao)" << res;
                    });
                });
            });
            return;
        }
        const QString js = QStringLiteral(
            "(() => {"
            "  function getCookie(name){"
            "    return document.cookie.split(';').map(s=>s.trim()).filter(s=>s.startsWith(name+'='))"
            "      .map(s=>s.substring(name.length+1))[0] || '';"
            "  }"
            "  const cookieTheme = getCookie('wr_theme');"
            "  const lsTheme = (localStorage && localStorage.getItem('wr_theme')) || '';"
            "  const current = (cookieTheme||lsTheme||'dark').toLowerCase();"
            "  const next = current==='white' ? 'dark' : 'white';"
            "  try { document.cookie = 'wr_theme='+next+'; domain=.weread.qq.com; path=/; max-age=31536000'; } catch(e) {}"
            "  try { localStorage && localStorage.setItem('wr_theme', next); } catch(e) {}"
            "  const delay=300;"
            "  console.log('[THEME] reload scheduled in',delay,'ms');"
            "  setTimeout(()=>{ console.log('[THEME] reloading now'); location.reload(); },delay);"
            "  return {ok:true, before:current, after:next, cookieAfter:getCookie('wr_theme'), lsAfter:(localStorage&&localStorage.getItem('wr_theme'))||''};"
            "})();"
        );
        m_view->page()->runJavaScript(js, [this](const QVariant &res){
            qInfo() << "[MENU] theme toggle" << res;
        });
    }
    void toggleFontFamily() {
        if (!m_view || !m_view->page()) return;
        m_firstFrameDone = false;
        m_reloadAttempts = 0;
        const QString js = QStringLiteral(
            "(() => {"
            "  const key='wrLocalSetting';"
            "  let setting={};"
            "  try{ setting=JSON.parse(localStorage.getItem(key)||'{}'); }catch(e){ setting={}; }"
            "  const cur=(setting.fontFamily||'wr_default_font').toLowerCase();"
            "  const custom='custom_noto_sans';"
            "  const next = (cur===custom) ? 'wr_default_font' : custom;"
            "  setting.fontFamily = next;"
            "  if(!setting.fontSizeLevel) setting.fontSizeLevel = 3;"
            "  try{ localStorage.setItem(key, JSON.stringify(setting)); }catch(e){}"
            "  const cssId='wr-font-override';"
            "  const exist=document.getElementById(cssId);"
            "  if (exist) exist.remove();"
            "  if (next===custom){"
            "    const style=document.createElement('style');"
            "    style.id=cssId;"
            "    style.textContent = \"@font-face{font-family:'CustomNotoSans';src:url('file:///home/root/.fonts/NotoSansCJKsc-Regular.otf') format('opentype');}\"+"
            "      \".renderTargetContent, .renderTargetContent * { font-family:'CustomNotoSans', 'Noto Sans CJK SC', 'Noto Sans SC', sans-serif !important; }\";"
            "    try{ (document.documentElement||document.body).appendChild(style); }catch(e){}"
            "  }"
            "  setTimeout(()=>location.reload(), 200);"
            "  return {ok:true,next};"
            "})();"
        );
        m_view->page()->runJavaScript(js, [this](const QVariant &res){
            qInfo() << "[MENU] font toggle" << res;
        });
    }
    void toggleService() {
        if (!m_view || !m_view->page()) return;
        m_firstFrameDone = false;
        m_reloadAttempts = 0;
        const QString cur = m_view->url().toString();
        const bool isDedao = cur.contains(QStringLiteral("dedao.cn"));
        const QUrl next = isDedao
            ? QUrl(QStringLiteral("https://weread.qq.com/"))
            : QUrl(QStringLiteral("https://www.dedao.cn/"));
        qInfo() << "[MENU] service toggle" << (isDedao ? "dedao->weread" : "weread->dedao") << "next" << next;
        m_view->load(next);
    }
    void applyDefaultLightTheme() {
        Q_UNUSED(m_view);
    }
    void dedaoScroll(bool forward) {
        if (!m_view || !m_view->page()) { m_navigating = false; return; }

        const int currentSeq = ++m_navSequence;
        m_navigating = true;

        // 看门狗保持 1200ms
        QTimer::singleShot(1200, this, [this, currentSeq](){
            if (m_navigating && m_navSequence == currentSeq) {
                m_navigating = false;
                qWarning() << "[PAGER] Force unlock (timeout 1200ms) seq" << currentSeq;
            }
        });

        const int step = forward ? 1000 : -1000;
        // 【打点1】记录 C++ 发出指令的时间
        const qint64 cppSendTime = QDateTime::currentMSecsSinceEpoch();
        qInfo() << "[PAGER] dedao dispatch seq" << currentSeq << "forward" << forward << "ts" << cppSendTime;

        const QString js = QStringLiteral(
            R"(
            (() => {
                try {
                    // 【打点2】记录 JS 真正开始执行的时间
                    const jsStartTime = Date.now();
                    const step = %1;

                    function wakeUp(_el) { return; }

                    let result = {ok:false, reason:'stuck'};

                    // 1) 缓存优先
                    if (window.__SCROLL_EL && window.__SCROLL_EL.isConnected) {
                        const el = window.__SCROLL_EL;
                        const before = el.scrollTop || 0;
                        el.scrollBy(0, step);
                        const after = el.scrollTop || 0;
                        if (Math.abs(after - before) > 1) {
                            wakeUp(el);
                            result = {ok:true, mode:'cached', tag:el.tagName, delta: after-before};
                        } else {
                            window.__SCROLL_EL = null;
                        }
                    }

                    // 2) 搜索候选
                    if (!result.ok) {
                        const candidates = ['.iget-reader-book', '.reader-content', '.iget-reader-container', '.reader-body', 'html', 'body'];
                        for (const sel of candidates) {
                            const el = document.querySelector(sel);
                            if (!el || !el.isConnected) continue;
                            const before = el.scrollTop || 0;
                            el.scrollBy(0, step);
                            const after = el.scrollTop || 0;
                            if (Math.abs(after - before) > 1) {
                                window.__SCROLL_EL = el;
                                wakeUp(el);
                                result = {ok:true, mode:'search', tag:el.tagName, delta: after-before};
                                break;
                            }
                        }
                    }

                    // 3) 兜底 Window
                    if (!result.ok) {
                        const bWin = window.scrollY;
                        window.scrollBy(0, step);
                        if (Math.abs(window.scrollY - bWin) > 0) {
                            result = {ok:true, mode:'window', delta:(window.scrollY - bWin)};
                        }
                    }

                    // 【打点3】记录 JS 执行结束的时间
                    const jsEndTime = Date.now();
                    result.t_js_start = jsStartTime;
                    result.t_js_end   = jsEndTime;
                    return result;

                } catch(e) { return {ok:false, error:String(e)}; }
            })()
            )"
        ).arg(step);

        m_view->page()->runJavaScript(js, [this, cppSendTime, currentSeq](const QVariant &res){
            // 【打点4】记录 C++ 收到回调的时间
            const qint64 cppRecvTime = QDateTime::currentMSecsSinceEpoch();

            const QVariantMap m = res.toMap();
            const qint64 jsStartTime = m.value("t_js_start").toLongLong();
            const qint64 jsEndTime   = m.value("t_js_end").toLongLong();

            const qint64 queueDelay   = jsStartTime - cppSendTime;       // 排队耗时
            const qint64 execTime     = jsEndTime   - jsStartTime;       // JS执行耗时
            const qint64 ipcDelay     = cppRecvTime - jsEndTime;         // 回传耗时
            const qint64 totalElapsed = cppRecvTime - cppSendTime;

            const int delta = m.value("delta").toInt();
            const QString mode = m.value("mode").toString();

            if (totalElapsed > 800) {
                qWarning().noquote() << QString("[PAGER] SLOW | Total: %1ms | Queue: %2ms | Exec: %3ms | IPC: %4ms | Mode: %5 | Delta: %6")
                                        .arg(totalElapsed).arg(queueDelay).arg(execTime).arg(ipcDelay).arg(mode).arg(delta);
            } else {
                qInfo().noquote() << QString("[PAGER] OK   | Total: %1ms | Queue: %2ms | Exec: %3ms | Mode: %4 | Delta: %5")
                                     .arg(totalElapsed).arg(queueDelay).arg(execTime).arg(mode).arg(delta);
            }

            if (m_navSequence == currentSeq) {
                m_navigating = false;
            } else {
                qInfo() << "[PAGER] dedao callback ignored, seq mismatch";
            }
        });
    }
    void goBack() {
        if (!m_view || !m_view->page()) return;
        auto *hist = m_view->page()->history();
        const bool canBack = hist && hist->canGoBack();
        const int count = hist ? hist->count() : -1;
        const int idx = hist ? hist->currentItemIndex() : -1;
        const QString currentUrl = m_view->url().toString();
        const bool inReader = currentUrl.contains(QStringLiteral("/web/reader/"));
        const bool isDedaoReader = isDedaoBook();

        qInfo() << "[BACK] canGoBack" << canBack << "count" << count
                << "currentIndex" << idx
                << "url" << m_view->url();

        // Dedao 特例：直接跳转详情页，避免空 history.back
        if (isDedaoReader) {
            const QString cur = m_view->url().toString();
            QString detail = cur;
            const int pos = cur.indexOf(QStringLiteral("/ebook/reader"));
            if (pos >= 0) {
                detail = cur;
                detail.replace(QStringLiteral("/ebook/reader"), QStringLiteral("/ebook/detail"));
            }
            qInfo() << "[BACK] dedao redirect to detail" << detail;
            m_allowDedaoDetailOnce = true; // 允许一次详情跳转
            m_view->setUrl(QUrl(detail));
            return;
        }

        if (canBack) {
            // Use JS history.back so SPA can handle its own stack; then log the result a moment later.
            m_view->page()->runJavaScript(QStringLiteral("window.history.back();"));
            QTimer::singleShot(800, this, [this]() {
                auto *h = m_view->page()->history();
                const int afterCount = h ? h->count() : -1;
                const int afterIdx = h ? h->currentItemIndex() : -1;
                qInfo() << "[BACK] after-back url" << m_view->url()
                        << "count" << afterCount << "currentIndex" << afterIdx;
            });
        } else if (inReader) {
            // Fallback: When browser history is empty (due to redirects),
            // navigate back to the main weread page instead of exiting
            qInfo() << "[BACK] history empty in reader, fallback to weread home";
            m_view->setUrl(QUrl(QStringLiteral("https://weread.qq.com/")));
        } else {
            // We're already at a top-level page (weread home), exit the app
            qInfo() << "[BACK] no history available, exiting";
            exitToXochitl();
        }
    }
    void allowDedaoDetailOnce() { m_allowDedaoDetailOnce = true; }
    void showMenu() {
        if (!m_menu) return;
        // stretch to top with margin to ensure visibility
        const int w = m_view ? m_view->width() : (this->width() > 0 ? this->width() : 954);
        const int x = 10;
        const int y = 70;   // further down by 10px
        const int h = 100;
        const int menuWidth = qMax(100, w - 2 * x); // full width, no right reserve
        m_menu->setGeometry(x, y, menuWidth, h);
        m_menu->setVisible(true);
        m_menu->raise();  // 确保菜单在最上层
        m_menu->setAttribute(Qt::WA_TransparentForMouseEvents, false);  // 确保菜单能接收鼠标事件
        m_menu->setAttribute(Qt::WA_AcceptTouchEvents, true);  // 确保菜单能接收触摸事件
        m_menu->activateWindow();  // 激活窗口以确保焦点
        qInfo() << "[MENU] show overlay";
        m_menuTimer.start();
        // 通知智能刷新管理器菜单显示
        if (m_smartRefresh) {
            m_smartRefresh->triggerMenu();
        }
        QTimer::singleShot(5000, this, [this](){ captureFrame(); });
        QTimer::singleShot(6000, this, [this](){ captureFrame(); });
        runDomDiagnostic();
    }
    void exitToXochitl() {
        // 先保存会话状态
        saveSessionState();
        // 启动退出脚本（停止后端，启动 xochitl）
        QProcess::startDetached(QStringLiteral("/home/root/weread/exit-wechatread.sh"));
        // 延迟退出，确保会话状态保存完成（saveSessionState 是异步的）
        QTimer::singleShot(500, this, []() {
            QApplication::quit();
        });
    }
    
    // 触发全屏清理刷新（GC16 FULL）- 用于手动清理残影
    void triggerFullRefresh() {
        if (m_fbRef) {
            qInfo() << "[EINK] Manual full refresh triggered (GC16 FULL) - clearing ghosting";
            m_fbRef->refreshCleanup(width(), height());
        } else {
            qWarning() << "[EINK] Cannot trigger full refresh: m_fbRef is null";
        }
    }
    
public slots:
    void sendBookState() {
        const bool isBook = isWeReadBook() || isDedaoBook();
        QByteArray b(1, isBook ? '\x01' : '\x00');
        m_stateSender.writeDatagram(b, QHostAddress(QStringLiteral("127.0.0.1")), 45456);
        qInfo() << "[STATE] isBookPage" << isBook << "url" << currentUrl;
        const bool wasBook = m_prevIsBookPage;
        m_prevIsBookPage = isBook;
        m_isBookPage = isBook;
        // 动态调整缩放：非书籍页放大到 2.0，书籍页保持 1.6
        if (m_view) {
            const qreal targetZoom = isBook ? 1.6 : 2.0;
            if (!qFuzzyCompare(m_view->zoomFactor(), targetZoom)) {
                m_view->setZoomFactor(targetZoom);
                qInfo() << "[ZOOM] set zoom" << targetZoom << "isBook" << isBook;
            }
        }
        if (isBook && !wasBook) {
            cancelPendingCaptures();  // 取消之前页面的待执行抓帧
            m_firstFrameDone = false;
            m_reloadAttempts = 0;
            m_highWhiteRescueDone = false;
            m_bannerHidden = false;
            m_dedaoProbed = false;
            m_emptyReadyPolls = 0;
            m_stallRescueTriggered = false;
            m_diagRan = false;
            m_contentReadyTriggered = false;
            m_scriptInventoryLogged = false;
            m_resourceLogged = false;
            m_textScanDone = false;
            m_rescueSeq = 0;
            m_iframeFixApplied = false;
            m_lowPowerCssInjected = false;
            QTimer::singleShot(500, this, [this](){ logScriptInventory(); });
            QTimer::singleShot(1000, this, [this](){ logResourceEntries(); });
            QTimer::singleShot(30000, this, [this](){ logScriptInventory(false); logResourceEntries(false); });
            QTimer::singleShot(60000, this, [this](){ logScriptInventory(false); logResourceEntries(false); logTextScan(false); });
            QTimer::singleShot(120000, this, [this](){ logScriptInventory(false); logResourceEntries(false); logTextScan(false); });
            QTimer::singleShot(150000, this, [this](){ logScriptInventory(false); logResourceEntries(false); logTextScan(false); });
        }
        if (!isBook) m_scriptInventoryLogged = false;
        updateHeartbeat();
        if (isBook && !wasBook) {
        }
    }
    void handleStateRequest() {
        while (m_stateResponder.hasPendingDatagrams()) {
            QByteArray d;
            d.resize(int(m_stateResponder.pendingDatagramSize()));
            QHostAddress sender;
            quint16 port = 0;
            m_stateResponder.readDatagram(d.data(), d.size(), &sender, &port);
            Q_UNUSED(d);
            sendBookState(); // reply by sending current state to 45456 as usual
            qInfo() << "[STATE] request received from" << sender.toString() << "port" << port;
        }
    }
private:
    QWebEngineView* m_view = nullptr;
    FbRefreshHelper* m_fbRef = nullptr;
    SmartRefreshManager* m_smartRefresh = nullptr; // 智能刷新管理器
    QTimer* m_idleCleanupTimer = nullptr; // 空闲清理定时器
    QTimer* m_sessionSaveTimer = nullptr; // 定期保存会话状态定时器（每分钟）
    mutable qint64 m_lastSessionSaveTime = 0;    // 上次保存会话状态的时间戳（用于防抖，mutable 允许在 const 方法中修改）
    QPushButton* m_uaButton = nullptr;
    // 已废弃：不再通过改 QTFB_KEY / 断开 qtfb 连接来“交回系统”，而是走后台模式（停止刷新/渲染）
    QWebEngineProfile* m_profile = nullptr;
    // UA 控制：微信书籍页用 Qt 默认 UA，其余用配置 UA
    QString m_uaNonWeRead;
    QString m_uaWeReadBook;
    QString m_kindleUA;
    QString m_ipadMiniUA;
    QString m_desktopChromeUA;  // 桌面版Chrome UA（用于微信读书首页）
    QString m_currentUA;
    QString m_weReadBookMode;
    QString m_uaMode = QStringLiteral("default");
    QString detectUaMode(const QString &ua) const {
        const QString low = ua.toLower();
        if (low.contains(QStringLiteral("ipad"))) return QStringLiteral("ipad");
        if (low.contains(QStringLiteral("kindle"))) return QStringLiteral("kindle");
        if (low.contains(QStringLiteral("android"))) return QStringLiteral("android");
        return QStringLiteral("default");
    }
    QFrame* m_menu = nullptr;
    QTimer m_menuTimer;
    QTimer m_heartbeatTimer;
    bool m_disablePrep = true;    // 关闭首帧捕获/样式准备
    bool m_disableRescue = true;  // 关闭救援/兜底
    int m_emptyReadyPolls = 0;
    bool m_stallRescueTriggered = false;
    bool m_firstFrameDone = false;
    int m_reloadAttempts = 0;
    int m_integrityReloads = 0;
    int m_bookEarlyReloads = 0;
    bool m_stylesOk = false;
    bool m_enableHighWhiteRescue = false; // 可开关的高白救援（默认暂停）
    bool m_highWhiteRescueDone = false;
    bool m_bannerHidden = false;
    bool m_diagRan = false;
    bool m_contentReadyTriggered = false;  // 内容准备好事件是否已触发
    // 智能延迟重试机制（低功耗）
    int m_contentRetryCount = 0;           // 内容重试计数器
    qint64 m_lastContentCheckTime = 0;     // 上次内容检查时间
    qint64 m_lastContentRetryTime = 0;    // 上次内容重试时间
    bool m_contentCheckScheduled = false;  // 内容检查是否已调度（避免重复调度）
    bool m_contentFirstCheckFailed = false; // 第一次检查是否失败（用于二次确认）
    static constexpr int MAX_CONTENT_RETRIES = 2;           // 最大重试次数（减少到2次）
    static constexpr int CONTENT_CHECK_DELAY_MS = 15000;    // 首次检查延迟（15秒，给内容足够时间加载）
    static constexpr int CONTENT_RETRY_INTERVAL_MS = 15000; // 重试间隔（15秒）
    static constexpr int CONTENT_CHECK_COOLDOWN_MS = 30000; // 检查冷却期（30秒）
    static constexpr int CONTENT_CONFIRM_DELAY_MS = 10000;  // 二次确认延迟（10秒，避免误判）
    bool m_scriptInventoryLogged = false;
    bool m_resourceLogged = false;
    bool m_textScanDone = false;
    int m_rescueSeq = 0;
    bool m_iframeFixApplied = false;
    bool m_lowPowerCssInjected = false;
    bool m_allowDedaoDetailOnce = false;
    QUdpSocket m_stateSender;
    QUdpSocket m_stateResponder;
    QUrl currentUrl;
    QString m_prevUrlStr;
    QString m_lastDedaoReaderUrl;
    bool m_isBookPage = false;
    bool m_prevIsBookPage = false;
    qint64 m_lastReloadTs = 0;
    qint64 m_bookEnterTs = 0;
    bool m_dedaoProbed = false;
    bool m_navigating = false; // 翻页防抖锁
    int m_navSequence = 0;     // 翻页序列号，防止僵尸回调
    qint64 m_navStartTime = 0;  // 翻页开始时间（用于检测慢速翻页）
    int m_pendingNavSeq = 0;    // 待处理的翻页序列号（用于取消机制）
    QTimer* m_navTimeoutTimer = nullptr;  // 翻页超时定时器（可取消）
    qint64 m_lastTouchTs = 0;
public:
    // 会话恢复相关方法（public，供 main() 调用）
    static QString getSessionStatePath();
    void saveSessionState() const;
    QUrl loadSessionUrl() const;
    int loadSessionScrollPosition() const;
    int m_restoredScrollY = 0;  // 恢复的滚动位置（public，供 main() 访问）
    bool m_isRestoringSession = false;  // 是否正在恢复会话（public，供 main() 访问）
    // 以下方法供外部类（如 GestureFilter）调用，需要保持 public
    bool isWeReadBook() const {
        const QString u = currentUrl.toString();
        // 放宽匹配：只要域是 weread.qq.com 且路径包含 /web/reader 即视为书籍页
        return u.contains(QStringLiteral("weread.qq.com")) &&
               u.contains(QStringLiteral("/web/reader"));
    }
    bool isKindleUA() const {
        const QString ua = m_currentUA.toLower();
        return ua.contains(QStringLiteral("kindle")) || m_uaMode.compare(QStringLiteral("kindle"), Qt::CaseInsensitive) == 0;
    }
    bool isWeReadKindleMode() const { return isWeReadBook() && isKindleUA(); }
    bool isDedaoBook() const {
        const QString u = currentUrl.toString();
        return u.contains(QStringLiteral("dedao.cn")) && u.contains(QStringLiteral("/ebook/reader"));
    }
    QWebEngineView* getView() const { return m_view; }
    SmartRefreshManager* getSmartRefresh() const { return m_smartRefresh; }
    void scheduleBookCaptures(bool force = false) {
        Q_UNUSED(force);
        // 一体化模式不抓帧，仅保留接口
    }
    void restartCaptureLoop() { /* no-op */ }
    void openDedaoMenu();
    void updateLastTouchTs(qint64 ts) { m_lastTouchTs = ts; }
private:
    void forceRepaintNudge() {
        if (!m_view || !m_view->page()) return;
        const QString js = QStringLiteral(
            "(() => {"
            "  try {"
            "    window.scrollBy(0,1);"
            "    setTimeout(()=>window.scrollBy(0,-1),50);"
            "    const b=document.body; if(b){ const op=b.style.opacity; b.style.opacity='0.999'; setTimeout(()=>{b.style.opacity=op||'';},50); }"
            "    return {ok:true};"
            "  } catch(e) { return {ok:false, error:String(e)}; }"
            "})();"
        );
        m_view->page()->runJavaScript(js, [](const QVariant &res){
            qInfo() << "[REPAINT_NUDGE]" << res;
        });
    }
    // 根据 URL 切换 UA：微信书籍页用 Qt 默认 UA，其余用配置的 iOS/Kindle/Android UA
    void updateUserAgentForUrl(const QUrl &url) {
        if (!m_profile) return;
        const QString u = url.toString();
        const bool weReadBook = u.contains(QStringLiteral("weread.qq.com")) &&
                                u.contains(QStringLiteral("/web/reader/"));
        const bool dedaoBook = u.contains(QStringLiteral("dedao.cn")) &&
                               u.contains(QStringLiteral("/ebook/reader"));
        // 检测是否是微信读书首页（weread.qq.com但不是书籍页）
        const bool weReadHome = u.contains(QStringLiteral("weread.qq.com")) && !weReadBook;
        QString targetUA;
        if (dedaoBook) {
            targetUA = m_kindleUA.isEmpty() ? m_uaNonWeRead : m_kindleUA;
        } else if (weReadBook) {
            targetUA = m_uaWeReadBook;
        } else if (weReadHome) {
            // 微信读书首页：强制使用桌面版UA（web）
            targetUA = m_desktopChromeUA;
            if (m_currentUA != m_desktopChromeUA) {
                qInfo() << "[UA] weread home: switching to web UA from" << m_currentUA << "to" << targetUA;
            }
        } else {
            targetUA = m_uaNonWeRead;
        }
        if (targetUA == m_currentUA) {
            // 仍然更新按钮，防止模式和显示不同步
            m_uaMode = detectUaMode(m_currentUA);
            updateUaButtonText(m_uaMode);
            return;
        }
        m_profile->setHttpUserAgent(targetUA);
        m_currentUA = targetUA;
        m_uaMode = detectUaMode(m_currentUA);
        qInfo() << "[UA] switched" << (weReadBook ? "weread-book" : (weReadHome ? "weread-home" : "non-weread")) << targetUA;
        updateUaButtonText(m_uaMode);
    }
    // 强制设置白色主题（只检查cookies），字体大小则根据localStorage设置（如果没有才设为默认值5）
    void ensureDefaultBookSettings() {
        if (!isWeReadBook() || !m_view || !m_view->page()) return;
        const QString js = QStringLiteral(
            "(function() {"
            "  try {"
            "    // 等待DOM准备就绪（最多等待1秒）"
            "    let retries = 0;"
            "    const checkAndSet = () => {"
            "      if (!document.body && !document.documentElement && retries < 10) {"
            "        retries++;"
            "        setTimeout(checkAndSet, 100);"
            "        return {ok: false, retrying: true, retries: retries};"
            "      }"
            "      if (!document.body && !document.documentElement) {"
            "        console.error('[DEFAULT] DOM not ready after 1s');"
            "        return {ok: false, error: 'DOM not ready'};"
            "      }"
      "      // 检查当前主题，如果是黑色则需要重新加载页面才能生效（cookie已在urlChanged时设置）"
            "      const getCookie = (name) => {"
            "        return document.cookie.split(';').map(s=>s.trim()).find(s=>s.startsWith(name+'='))?.split('=')[1] || '';"
            "      };"
            "      const oldCookieTheme = getCookie('wr_theme');"
            "      const bodyClass = document.body ? document.body.className : '';"
            "      const isDark = bodyClass.includes('wr_darkTheme') || bodyClass.includes('dark') || oldCookieTheme === 'dark';"
            "      // 如果检测到是黑色主题，重新加载页面以应用新的cookie值"
            "      if (isDark) {"
            "        console.log('[DEFAULT] Dark theme detected, reloading page to apply white theme...');"
            "        setTimeout(() => { location.reload(); }, 100);"
            "        return {ok: true, themeSet: true, reloading: true, oldTheme: oldCookieTheme};"
            "      }"
            "      // 如果不是黑色，强制设置DOM的class和attribute（确保立即生效）"
            "      try {"
            "        if (document.body) {"
            "          document.body.classList.add('wr_whiteTheme');"
            "          document.body.classList.remove('wr_darkTheme');"
            "          document.body.setAttribute('data-theme', 'light');"
            "        }"
            "        if (document.documentElement) {"
            "          document.documentElement.setAttribute('data-theme', 'light');"
            "        }"
            "      } catch(e) { console.error('[DEFAULT] Failed to set theme DOM:', e); }"
            "    // 检查localStorage中的字体设置，如果没有才设置为5"
            "    let fontSizeLevel = null;"
            "    try {"
            "      const setting = JSON.parse(localStorage.getItem('wrLocalSetting') || '{}');"
            "      fontSizeLevel = setting.fontSizeLevel;"
            "    } catch(e) { console.error('[DEFAULT] Failed to read font size:', e); }"
            "    // 只有在没有字体设置时才设置默认值5"
            "    if (fontSizeLevel === null || fontSizeLevel === undefined || fontSizeLevel === '') {"
            "      try {"
            "        let setting = {};"
            "        try { setting = JSON.parse(localStorage.getItem('wrLocalSetting') || '{}'); } catch(e) { setting = {}; }"
            "        setting.fontSizeLevel = 5;"
            "        if (!setting.fontFamily) setting.fontFamily = 'wr_default_font';"
            "        localStorage.setItem('wrLocalSetting', JSON.stringify(setting));"
            "        console.log('[DEFAULT] Set default font size: 5 (was empty)');"
            "        return {ok: true, themeSet: true, fontSet: true, fontSizeLevel: 'set to 5'};"
            "      } catch(e) { console.error('[DEFAULT] Failed to set font size:', e); return {ok: false, error: 'font set failed: ' + String(e)}; }"
            "    } else {"
            "      console.log('[DEFAULT] Using existing font size from localStorage:', fontSizeLevel);"
            "      return {ok: true, themeSet: true, fontSet: false, fontSizeLevel: fontSizeLevel};"
            "    }"
            "    };"
            "    return checkAndSet();"
            "  } catch(e) { return {ok: false, error: String(e)}; }"
            "})()"
        );
        m_view->page()->runJavaScript(js, [](const QVariant &res){
            if (res.isValid()) {
                qInfo() << "[DEFAULT] Book settings:" << res;
            } else {
                qWarning() << "[DEFAULT] Book settings: JavaScript returned invalid result";
            }
        });
    }
    void ensureDedaoDefaults() {
        if (!isDedaoBook() || !m_view || !m_view->page()) return;
        // 强制 Kindle UA（需求：进入得到书籍页默认 UA 为 Kindle）
        if (!m_kindleUA.isEmpty() && m_profile && m_profile->httpUserAgent() != m_kindleUA) {
            m_profile->setHttpUserAgent(m_kindleUA);
            m_currentUA = m_kindleUA;
            m_uaMode = detectUaMode(m_currentUA);
            updateUaButtonText(m_uaMode);
            qInfo() << "[DEDAO] UA forced to kindle";
        }
        // 缩放：2.0
        const qreal targetZoom = 2.0;
        if (!qFuzzyCompare(m_view->zoomFactor(), targetZoom)) {
            m_view->setZoomFactor(targetZoom);
            qInfo() << "[DEDAO] zoom set" << targetZoom;
        }
    }
    void scheduleCapture(int delayMs = 100) { Q_UNUSED(delayMs); /* no-op in integrated mode */ }
    // 仅针对微信读书书籍页：对齐滚动到行高整数倍并添加轻微留白，避免半截行
    void alignWeReadPagination() {
        if (!isWeReadBook() || m_weReadBookMode != QStringLiteral("mobile") || !m_view || !m_view->page()) return;
        const QString js = QStringLiteral(
            "(() => {"
            "  const el = document.querySelector('.renderTargetContent') || document.scrollingElement || document.documentElement;"
            "  if (!el) return {ok:false, reason:'no-container'};"
            "  try {"
            "    // el.style.padding = '20px 35px'; // 临时禁用：排查布局/隐藏问题"
            "    el.style.boxSizing = 'border-box';"
            "    el.style.width = '100%';"
            "    el.style.maxWidth = '100%';"
            "  } catch(e) {}"
            "  const sample = el.querySelector('p, div, span');"
            "  const lh = sample ? parseFloat(getComputedStyle(sample).lineHeight) || 32 : 32;"
            "  const padTop = parseFloat(getComputedStyle(el).paddingTop) || 0;"
            "  const cur = el.scrollTop;"
            "  const aligned = Math.max(0, Math.round((cur - padTop) / lh) * lh + padTop);"
            "  if (Math.abs(aligned - cur) > 0.5) el.scrollTo({ top: aligned, behavior: 'auto' });"
            "  return {ok:true, from:cur, to:aligned, lineHeight:lh};"
            "})()"
        );
        m_view->page()->runJavaScript(js, [](const QVariant &res){
            qInfo() << "[PAGER] align weRead" << res;
        });
    }
    // 【视觉诊断】正文有字但不显示时，采集容器的可见性/尺寸/遮挡信息
    void runVisualDiagnostic() {
        if (!m_view || !m_view->page()) return;
        const QString js = QStringLiteral(
            "(() => {"
            "  try {"
            "    const target = document.querySelector('.renderTargetContent') || document.querySelector('.readerChapterContent') || document.body;"
            "    if (!target) return {error: 'target-not-found'};"
            "    const style = window.getComputedStyle(target);"
            "    const rect = target.getBoundingClientRect();"
            "    const mask = document.querySelector('.loading, .mask, .reader_loading');"
            "    let maskInfo = 'none';"
            "    if (mask) {"
            "      const ms = window.getComputedStyle(mask);"
            "      if (ms.display !== 'none' && ms.visibility !== 'hidden' && ms.opacity !== '0') {"
            "        maskInfo = {cls: mask.className, zIndex: ms.zIndex, bg: ms.backgroundColor, disp: ms.display, vis: ms.visibility, op: ms.opacity};"
            "      }"
            "    }"
            "    const iframeInfo = (()=>{"
            "      const frames = Array.from(document.querySelectorAll('iframe'));"
            "      const samples = [];"
            "      frames.forEach((f,idx)=>{"
            "        if (samples.length>=3) return;"
            "        const r = f.getBoundingClientRect();"
            "        const entry = {idx, src:(f.src||'').slice(0,120), rect:{x:r.x,y:r.y,w:r.width,h:r.height}};"
            "        try {"
            "          const d = f.contentDocument || (f.contentWindow && f.contentWindow.document);"
            "          if (d && d.body && d.body.innerText) entry.textLen = d.body.innerText.length;"
            "        } catch(_) { entry.blocked = true; }"
            "        samples.push(entry);"
            "      });"
            "      return {count:frames.length, samples};"
            "    })();"
            "    return {"
            "      tag: target.tagName,"
            "      cls: target.className,"
            "      rect: {x: rect.x, y: rect.y, w: rect.width, h: rect.height},"
            "      style: {display: style.display, visibility: style.visibility, opacity: style.opacity, zIndex: style.zIndex, position: style.position, color: style.color, bgColor: style.backgroundColor, font: style.fontFamily},"
            "      mask: maskInfo,"
            "      textLen: (target.innerText||'').length,"
            "      iframe: iframeInfo"
            "    };"
            "  } catch(e) { return {error: String(e)}; }"
            "})()"
        );
        m_view->page()->runJavaScript(js, [](const QVariant &res){
            qWarning().noquote() << "[VISUAL_DIAG]" << res;
        });
    }
    // 应用书籍页样式修复和视觉诊断（从 Ready 机制中提取）
    void applyBookPageFixes() {
        if (!isWeReadBook()) return;
        if (!m_view || !m_view->page()) return;
        
        // 延迟执行，等待页面内容加载
        QTimer::singleShot(500, this, [this]() {
            // 检查是否有文本内容
            m_view->page()->runJavaScript(QStringLiteral(
                "(() => {"
                "  try {"
                "    const bodyLen = (document.body && document.body.innerText) ? document.body.innerText.length : 0;"
                "    const cont = document.querySelector('.renderTargetContent');"
                "    const contLen = cont ? ((cont.innerText||'').length) : 0;"
                "    let iframeText = 0;"
                "    const frames = Array.from(document.querySelectorAll('iframe'));"
                "    frames.forEach(f=>{"
                "      try{ const d=f.contentDocument||f.contentWindow?.document; if(d&&d.body&&d.body.innerText){ iframeText += d.body.innerText.length; } }catch(_e){}"
                "    });"
                "    const hasText = (contLen > 100) || (bodyLen > 500) || (iframeText > 300);"
                "    return {hasText, bodyLen, contLen, iframeText};"
                "  } catch(e){ return {error:String(e)}; }"
                "})()"
            ), [this](const QVariant &res){
                const auto m = res.toMap();
                const bool hasText = m.value(QStringLiteral("hasText")).toBool();
                
                // 触发 CONTENT_READY 高优先级事件（不受递增阈值限制）
                if (hasText && !m_contentReadyTriggered) {
                    m_contentReadyTriggered = true;
                    if (m_smartRefresh) {
                        m_smartRefresh->triggerContentReady();
                        qInfo() << "[CONTENT_READY] Content ready detected, triggering refresh"
                                << "bodyLen=" << m.value(QStringLiteral("bodyLen")).toInt()
                                << "contLen=" << m.value(QStringLiteral("contLen")).toInt()
                                << "iframeText=" << m.value(QStringLiteral("iframeText")).toInt();
                    }
                }
                
                if (hasText && !m_diagRan) {
                    m_diagRan = true;
                    runVisualDiagnostic();
                    logTextScan();
                }
                
                // 应用 iframe 修复样式
                if (hasText && !m_iframeFixApplied) {
                    m_iframeFixApplied = true;
                    const QString fixJs = QStringLiteral(
                        "(() => {"
                        "  try {"
                        "    const cont = document.querySelector('.renderTargetContent');"
                        "    if (cont) {"
                        "      cont.style.minHeight = '100vh';"
                        "      cont.style.width = '100%';"
                        "      cont.style.display = 'block';"
                        "      cont.style.opacity = '1';"
                        "      cont.style.visibility = 'visible';"
                        "      cont.style.background = '#fff';"
                        "    }"
                        "    const iframes = Array.from(document.querySelectorAll('iframe'));"
                        "    iframes.forEach(f => {"
                        "      f.style.display = 'block';"
                        "      f.style.minHeight = '100vh';"
                        "      f.style.width = '100%';"
                        "      try {"
                        "        const d = f.contentDocument || (f.contentWindow && f.contentWindow.document);"
                        "        if (d && d.body) {"
                        "          d.body.style.background = '#fff';"
                        "          d.body.style.color = '#000';"
                        "          d.body.style.opacity = '1';"
                        "          d.documentElement && (d.documentElement.style.background = '#fff');"
                        "        }"
                        "      } catch(_) {}"
                        "    });"
                        "    window.scrollBy(0,1); setTimeout(()=>window.scrollBy(0,-1),30);"
                        "    return {ok:true, iframes: iframes.length};"
                        "  } catch(e){ return {ok:false, error:String(e)};}"
                        "})()"
                    );
                    m_view->page()->runJavaScript(fixJs, [](const QVariant &res){
                        qInfo() << "[STYLE] iframe fix" << res;
                    });
                }
                
                // 注入低功耗样式（仅一次）
                if (hasText && !m_lowPowerCssInjected) {
                    m_lowPowerCssInjected = true;
                    const QString lowPowerCss = QStringLiteral(
                        "(() => {"
                        "  try {"
                        "    if (document.getElementById('weread-low-power-style')) return {ok:true, existed:true};"
                        "    const style = document.createElement('style');"
                        "    style.id = 'weread-low-power-style';"
                        "    style.textContent = `"
                        "      * {"
                        "        animation-duration: 0.001s !important;"
                        "        animation-iteration-count: 1 !important;"
                        "        transition-duration: 0s !important;"
                        "        scroll-behavior: auto !important;"
                        "      }"
                        "      html, body, .readerChapterContent, .renderTargetContent, .readerContent {"
                        "        scroll-behavior: auto !important;"
                        "        transition: none !important;"
                        "        animation: none !important;"
                        "      }"
                        "      .loading, .mask, .reader_loading {"
                        "        transition: none !important;"
                        "        animation: none !important;"
                        "      }"
                        "    `;"
                        "    document.head.appendChild(style);"
                        "    return {ok:true, injected:true};"
                        "  } catch(e) { return {ok:false, error:String(e)}; }"
                        "})()"
                    );
                    m_view->page()->runJavaScript(lowPowerCss, [](const QVariant &res){
                        qInfo() << "[STYLE] low-power css" << res;
                    });
                }
            });
        });
    }
private:
    void updateHeartbeat() {
        Q_UNUSED(m_isBookPage);
        // heartbeat captures disabled; keep stub to avoid timer reuse
        m_heartbeatTimer.stop();
    }
    void cancelPendingCaptures() { /* no-op */ }
    qint64 m_lastKeepaliveNoStateLogMs = 0;
    
    // 智能延迟重试：检查内容并重试（低功耗）
    void checkContentAndRetryIfNeeded() {
        if (!m_view || !m_view->page()) return;
        
        const qint64 now = QDateTime::currentMSecsSinceEpoch();
        
        // 冷却期检查：如果最近检查过，跳过（避免频繁检查）
        // 但如果这是二次确认检查（m_contentFirstCheckFailed == true），则跳过冷却期
        if (!m_contentFirstCheckFailed && now - m_lastContentCheckTime < CONTENT_CHECK_COOLDOWN_MS) {
            qInfo() << "[RETRY] Skipping check (cooldown, last check was" 
                    << (now - m_lastContentCheckTime) << "ms ago)";
            return;
        }
        
        m_lastContentCheckTime = now;
        
        // 调用 keepAliveNearChapterEnd 检查内容状态（带重试逻辑）
        keepAliveNearChapterEndWithRetry();
    }
    
    void keepAliveNearChapterEnd() {
        if (!m_view || !m_view->page()) return;
        const QString js = QStringLiteral(
            "(() => {"
            "  try {"
            "    const state = (window.__INITIAL_STATE__ && window.__INITIAL_STATE__.reader) || "
            "                  (window.__NUXT__ && window.__NUXT__.state && window.__NUXT__.state.reader) || null;"
            "    const obs = window.__WR_CHAPTER_OBS || {};"
            "    let source = '';"
            "    let bookId = '';"
            "    let idx = -1;"
            "    let total = 0;"
            "    let uid = null;"
            "    if (state && state.chapterList && state.chapterList.length && state.chapterUid) {"
            "      source = 'state';"
            "      const list = state.chapterList || [];"
            "      uid = state.chapterUid;"
            "      idx = list.findIndex(c => c && (c.chapterUid === uid || c.chapter_uid === uid || String(c.chapterUid) === String(uid)));"
            "      total = list.length || 0;"
            "      bookId = state.bookId || state.book_id || '';"
            "    } else if (obs && (obs.bookId || obs.chapterUid || obs.total || obs.idx!==undefined || obs.localIdx!==undefined)) {"
            "      source = 'observer';"
            "      bookId = obs.bookId || '';"
            "      uid = obs.chapterUid || null;"
            "      if (obs.total) total = obs.total;"
            "      if (obs.idx !== undefined) idx = obs.idx;"
            "      if (idx < 0 && obs.localIdx !== undefined) idx = obs.localIdx;"
            "    }"
            "    const urlMatch = (location.href || '').match(/reader\\/([a-zA-Z0-9]+)/);"
            "    if (!bookId) bookId = urlMatch ? urlMatch[1] : '';"
            "    let hasLocal=false;"
            "    let localIdx=-1;"
            "    try {"
            "      const lcRaw = localStorage.getItem('book:lastChapters');"
            "      if (lcRaw) {"
            "        hasLocal=true;"
            "        const parsed = JSON.parse(lcRaw);"
            "        if (bookId && parsed && parsed[bookId]!=null) {"
            "          localIdx = parseInt(parsed[bookId]);"
            "          if (idx < 0) idx = localIdx;"
            "        }"
            "      }"
            "    } catch(e) {}"
            "    const near = (total > 0 && idx >= 0) ? (idx >= (total - 3)) : false;"
            "    if (near) {"
            "      fetch('https://weread.qq.com/web/shelf?nocache=' + Date.now(), {mode:'no-cors'}).catch(()=>{});"
            "    }"
            "    const ok = (total > 0 && idx >= 0);"
            "    return {ok, source, bookId, chapterUid: uid, idx, total, near, hasLocal, localIdx};"
            "  } catch(e) { return {ok:false, error:''+e}; }"
            "})();"
        );
        m_view->page()->runJavaScript(js, [this](const QVariant &res){
            const QVariantMap map = res.toMap();
            const bool ok = map.value(QStringLiteral("ok")).toBool();
            if (!ok && map.value(QStringLiteral("reason")).toString() == QLatin1String("no_state")) {
                const qint64 now = QDateTime::currentMSecsSinceEpoch();
                if (now - m_lastKeepaliveNoStateLogMs > 10000) {
                    qInfo() << "[KEEPALIVE]" << res;
                    m_lastKeepaliveNoStateLogMs = now;
                }
                return;
            }
            qInfo() << "[KEEPALIVE]" << res;
        });
    }
    
    // 带重试逻辑的内容检查（用于智能延迟重试）
    void keepAliveNearChapterEndWithRetry() {
        if (!m_view || !m_view->page()) return;
        const QString js = QStringLiteral(
            "(() => {"
            "  try {"
            "    const state = (window.__INITIAL_STATE__ && window.__INITIAL_STATE__.reader) || "
            "                  (window.__NUXT__ && window.__NUXT__.state && window.__NUXT__.state.reader) || null;"
            "    const obs = window.__WR_CHAPTER_OBS || {};"
            "    let source = '';"
            "    let bookId = '';"
            "    let idx = -1;"
            "    let total = 0;"
            "    let uid = null;"
            "    if (state && state.chapterList && state.chapterList.length && state.chapterUid) {"
            "      source = 'state';"
            "      const list = state.chapterList || [];"
            "      uid = state.chapterUid;"
            "      idx = list.findIndex(c => c && (c.chapterUid === uid || c.chapter_uid === uid || String(c.chapterUid) === String(uid)));"
            "      total = list.length || 0;"
            "      bookId = state.bookId || state.book_id || '';"
            "    } else if (obs && (obs.bookId || obs.chapterUid || obs.total || obs.idx!==undefined || obs.localIdx!==undefined)) {"
            "      source = 'observer';"
            "      bookId = obs.bookId || '';"
            "      uid = obs.chapterUid || null;"
            "      if (obs.total) total = obs.total;"
            "      if (obs.idx !== undefined) idx = obs.idx;"
            "      if (idx < 0 && obs.localIdx !== undefined) idx = obs.localIdx;"
            "    }"
            "    const urlMatch = (location.href || '').match(/reader\\/([a-zA-Z0-9]+)/);"
            "    if (!bookId) bookId = urlMatch ? urlMatch[1] : '';"
            "    let hasLocal=false;"
            "    let localIdx=-1;"
            "    try {"
            "      const lcRaw = localStorage.getItem('book:lastChapters');"
            "      if (lcRaw) {"
            "        hasLocal=true;"
            "        const parsed = JSON.parse(lcRaw);"
            "        if (bookId && parsed && parsed[bookId]!=null) {"
            "          localIdx = parseInt(parsed[bookId]);"
            "          if (idx < 0) idx = localIdx;"
            "        }"
            "      }"
            "    } catch(e) {}"
            "    const near = (total > 0 && idx >= 0) ? (idx >= (total - 3)) : false;"
            "    if (near) {"
            "      fetch('https://weread.qq.com/web/shelf?nocache=' + Date.now(), {mode:'no-cors'}).catch(()=>{});"
            "    }"
            "    const ok = (total > 0 && idx >= 0);"
            "    return {ok, source, bookId, chapterUid: uid, idx, total, near, hasLocal, localIdx};"
            "  } catch(e) { return {ok:false, error:''+e}; }"
            "})();"
        );
        m_view->page()->runJavaScript(js, [this](const QVariant &res){
            const QVariantMap map = res.toMap();
            const bool ok = map.value(QStringLiteral("ok")).toBool();
            const int total = map.value(QStringLiteral("total")).toInt();
            const QString bookId = map.value(QStringLiteral("bookId")).toString();
            
            // 检测书籍内容加载失败
            const bool isBookPage = !bookId.isEmpty();
            const bool contentFailed = isBookPage && (!ok || total == 0);
            
            if (contentFailed) {
                const qint64 now = QDateTime::currentMSecsSinceEpoch();
                
                // 二次确认机制：第一次检查失败后，延迟再次检查，避免误判
                if (!m_contentFirstCheckFailed) {
                    // 第一次检查失败，标记并延迟进行二次确认
                    m_contentFirstCheckFailed = true;
                    qInfo() << "[RETRY] First check failed, scheduling confirmation check after" 
                            << CONTENT_CONFIRM_DELAY_MS << "ms. BookId:" << bookId 
                            << "ok:" << ok << "total:" << total;
                    QTimer::singleShot(CONTENT_CONFIRM_DELAY_MS, this, [this]() {
                        checkContentAndRetryIfNeeded();  // 二次确认检查
                    });
                    return;  // 不立即重试，等待二次确认
                }
                
                // 二次确认也失败，才真正触发重试
                m_contentFirstCheckFailed = false;  // 重置标志
                
                // 检查重试间隔：如果最近重试过，跳过（避免频繁重试）
                if (now - m_lastContentRetryTime < CONTENT_RETRY_INTERVAL_MS) {
                    qInfo() << "[RETRY] Skipping retry (interval, last retry was" 
                            << (now - m_lastContentRetryTime) << "ms ago)";
                    return;
                }
                
                // 检查最大重试次数
                if (m_contentRetryCount >= MAX_CONTENT_RETRIES) {
                    qWarning() << "[RETRY] Max retries reached (" << MAX_CONTENT_RETRIES 
                               << "), giving up. BookId:" << bookId;
                    return;
                }
                
                m_contentRetryCount++;
                m_lastContentRetryTime = now;
                
                qInfo() << "[RETRY] Content load failed (confirmed), retrying via JS API (" << m_contentRetryCount 
                        << "/" << MAX_CONTENT_RETRIES << ") BookId:" << bookId 
                        << "ok:" << ok << "total:" << total;
                
                // 触发重试：通过JavaScript重新触发API请求（不重新加载页面）
                if (m_view && m_view->page()) {
                    // 直接调用重试函数，不等待Promise结果（因为Qt的runJavaScript不能直接处理Promise）
                    const QString retryJs = QStringLiteral(
                        "(function() {"
                        "  try {"
                        "    if (window.__WR_RETRY_BOOK_READ__) {"
                        "      window.__WR_RETRY_BOOK_READ__().then(() => {"
                        "        console.log('[RETRY] JS API retry succeeded');"
                        "      }).catch(err => {"
                        "        console.error('[RETRY] JS API retry failed:', err);"
                        "      });"
                        "      return {ok: true, method: 'js_api_retry_triggered'};"
                        "    } else {"
                        "      return {ok: false, error: 'retry_function_not_available'};"
                        "    }"
                        "  } catch(e) {"
                        "    return {ok: false, error: String(e)};"
                        "  }"
                        "})()"
                    );
                    
                    m_view->page()->runJavaScript(retryJs, [this, bookId](const QVariant &res) {
                        QVariantMap map = res.toMap();
                        bool jsOk = map.value(QStringLiteral("ok")).toBool();
                        if (jsOk) {
                            qInfo() << "[RETRY] JavaScript API retry triggered for BookId:" << bookId;
                        } else {
                            QString error = map.value(QStringLiteral("error")).toString();
                            qWarning() << "[RETRY] JavaScript API retry function not available for BookId:" << bookId 
                                       << "error:" << error;
                            // 如果JS重试函数不可用，降级为页面重载（仅作为最后手段）
                            if (m_contentRetryCount >= MAX_CONTENT_RETRIES) {
                                qInfo() << "[RETRY] Falling back to page reload (last resort)";
                                if (m_view) {
                                    m_view->reload();
                                }
                            }
                        }
                    });
                }
            } else if (ok && total > 0) {
                // 内容加载成功，重置所有状态
                if (m_contentRetryCount > 0) {
                    qInfo() << "[RETRY] Content loaded successfully after" 
                            << m_contentRetryCount << "retries";
                    m_contentRetryCount = 0;
                }
                m_contentFirstCheckFailed = false;  // 重置第一次检查失败标志
            }
            
            // 原有的日志记录
            qInfo() << "[KEEPALIVE]" << res;
        });
    }
    void runDomDiagnostic() {
        if (!m_view || !m_view->page()) return;
        const QString js = QStringLiteral(
            "(() => {"
            "  const report={url:location.href};"
            "  const catSelectors=['.readerControls .catalog','.readerControls_item.catalog','.catalog','.readerCatalog','button[title*=\"\\u76ee\\u5f55\"]','[data-action=\"catalog\"]'];"
            "  const catFound=catSelectors.map(sel=>{const el=document.querySelector(sel);return el?{sel,visible:getComputedStyle(el).display!=='none',cls:el.className,tag:el.tagName}:null;}).filter(Boolean);"
            "  const catText=[];document.querySelectorAll('button,div[role=\"button\"],a,span').forEach(el=>{const t=(el.textContent||'').trim();if(t.includes('\\u76ee\\u5f55'))catText.push({tag:el.tagName,cls:el.className,visible:getComputedStyle(el).display!=='none'});});"
            "  const panel=document.querySelector('.readerCatalog');"
            "  report.catalog={found:catFound, byText:catText.slice(0,5), panelVisible: !!panel && getComputedStyle(panel).display!=='none'};"
            "  const dots=Array.from(document.querySelectorAll('.reader_font_control_slider_track_level_dot_container .reader_font_control_slider_track_level_dot'));"
            "  report.font={total:dots.length, dots:dots.slice(0,7).map(d=>({cls:d.className,active:/(show|active|current)/.test(d.className)})), panelVisible: !!document.querySelector('.readerControls') && getComputedStyle(document.querySelector('.readerControls')).display!=='none', bodyClass:document.body.className};"
            "  const themeBtns=Array.from(document.querySelectorAll('.readerControls .dark, .readerControls .white, .readerControls_item.dark, .readerControls_item.white'));"
            "  report.theme={count:themeBtns.length, buttons:themeBtns.slice(0,4).map(b=>({cls:b.className,vis:getComputedStyle(b).display!=='none'})), dataTheme: document.body.getAttribute('data-theme')||document.documentElement.getAttribute('data-theme')||'', bodyClass:document.body.className, htmlClass:document.documentElement.className};"
            "  const controls=Array.from(document.querySelectorAll('.readerControls > *')).slice(0,10).map(el=>({tag:el.tagName,cls:el.className,text:(el.textContent||'').trim().slice(0,30)}));"
            "  report.controls=controls;"
            "  return report;"
            "})();"
        );
        m_view->page()->runJavaScript(js, [](const QVariant &res){
            const auto map = res.toMap();
            qInfo() << "[DIAG] url" << map.value(QStringLiteral("url")).toString();
            const auto catalog = map.value(QStringLiteral("catalog")).toMap();
            qInfo() << "[DIAG] catalog found" << catalog.value(QStringLiteral("found")).toList().size()
                    << "byText" << catalog.value(QStringLiteral("byText")).toList().size()
                    << "panelVisible" << catalog.value(QStringLiteral("panelVisible")).toBool();
            const auto font = map.value(QStringLiteral("font")).toMap();
            qInfo() << "[DIAG] font dots" << font.value(QStringLiteral("total")).toInt()
                    << "panelVisible" << font.value(QStringLiteral("panelVisible")).toBool()
                    << "bodyClass" << font.value(QStringLiteral("bodyClass")).toString();
            const auto theme = map.value(QStringLiteral("theme")).toMap();
            qInfo() << "[DIAG] theme buttons" << theme.value(QStringLiteral("count")).toInt()
                    << "dataTheme" << theme.value(QStringLiteral("dataTheme")).toString()
                    << "bodyClass" << theme.value(QStringLiteral("bodyClass")).toString()
                    << "htmlClass" << theme.value(QStringLiteral("htmlClass")).toString();
            const auto controls = map.value(QStringLiteral("controls")).toList();
            QStringList ctrlSumm;
            for (const auto &c : controls) {
                const auto m = c.toMap();
                ctrlSumm << (m.value(QStringLiteral("tag")).toString() + ":" + m.value(QStringLiteral("cls")).toString());
            }
            qInfo() << "[DIAG] readerControls children" << ctrlSumm.join(" | ");
        });
    }
    void applyBookBoldIfNeeded() {
        if (!m_view || !m_view->page()) return;
        if (!isWeReadBook()) return; // 仅对微信书籍页加粗，避免干扰得到
        const QString js = QStringLiteral(
            "(() => {"
            "  if (!window.__WR_APPLY_BOLD) {"
            "    window.__WR_APPLY_BOLD = function(){"
            "      const ready = document.readyState === 'complete' || document.readyState === 'interactive';"
            "      if (!ready) { setTimeout(()=>window.__WR_APPLY_BOLD && window.__WR_APPLY_BOLD(), 100); return {ok:false, reason:'not-ready'}; }"
            "      const root = document.documentElement || document.body;"
            "      if (!root) { setTimeout(()=>window.__WR_APPLY_BOLD && window.__WR_APPLY_BOLD(), 100); return {ok:false, reason:'no-root'}; }"
            "      if (window.__WR_BOLD__) return {ok:true, skipped:true};"
            "      const style=document.createElement('style');"
            "      style.id='wr-bold-text';"
            "      style.textContent = '.renderTargetContent, .renderTargetContent * { font-weight: 600 !important; }';"
            "      try { root.appendChild(style); window.__WR_BOLD__=true; return {ok:true, applied:true}; }"
            "      catch(e){ setTimeout(()=>window.__WR_APPLY_BOLD && window.__WR_APPLY_BOLD(), 200); return {ok:false, reason:'append-fail', error:''+e}; }"
            "    };"
            "  }"
            "  return window.__WR_APPLY_BOLD();"
            "})();"
        );
        m_view->page()->runJavaScript(js, [this](const QVariant &res){
            qInfo() << "[STYLE] bold apply" << res;
            const QVariantMap m = res.toMap();
            if (m.value(QStringLiteral("ok")).toBool()) m_stylesOk = true;
        });
    }
    void applyPureTheme() {
        if (!m_view || !m_view->page()) return;
        const bool isBook = isWeReadBook();
        const QString js = QStringLiteral(
            "(() => {"
            "  if (!window.__WR_APPLY_THEME) {"
            "    window.__WR_APPLY_THEME = function(){"
            "      const ready = document.readyState === 'complete' || document.readyState === 'interactive';"
            "      if (!ready) { setTimeout(()=>window.__WR_APPLY_THEME && window.__WR_APPLY_THEME(), 100); return {ok:false, reason:'not-ready'}; }"
            "      const isBook = location.href.includes('/web/reader/');"
            "      const root = document.documentElement || document.body;"
            "      if (!root) { setTimeout(()=>window.__WR_APPLY_THEME && window.__WR_APPLY_THEME(), 100); return {ok:false, reason:'no-root'}; }"
            "      let style = document.getElementById('wr-pure-theme');"
            "      if (!isBook) { if (style) style.remove(); return {ok:true, removed:true}; }"
            "      if (!style) {"
            "        style = document.createElement('style'); style.id='wr-pure-theme';"
            "        try { root.appendChild(style); } catch(e) { setTimeout(()=>window.__WR_APPLY_THEME && window.__WR_APPLY_THEME(), 200); return {ok:false, reason:'append-fail', error: ''+e}; }"
            "      }"
            "      const cls = document.body.className || '';"
            "      const light = cls.includes('wr_whiteTheme');"
            "      const bg = light ? '#eeeeee' : '#111111';"
            "      const fg = light ? '#111111' : '#eeeeee';"
            "      style.textContent = `\n"
            "        .renderTargetContent, .renderTargetContent * { color:${fg} !important; background-color:${bg} !important; text-shadow: none !important; filter: none !important; }\n"
            "        .renderTargetContent img, .renderTargetContent svg, .renderTargetContent canvas, .renderTargetContent video { background-color: transparent !important; color: inherit !important; filter: none !important; }\n"
            "        * { transition: none !important; animation: none !important; text-shadow: none !important; filter: none !important; }\n"
            "      `;"
            "      return {ok:true, applied:true, light};"
            "    };"
            "  }"
            "  try { return window.__WR_APPLY_THEME(); } catch(e){ setTimeout(()=>window.__WR_APPLY_THEME && window.__WR_APPLY_THEME(), 200); return {ok:false, reason:'apply-error', error:''+e}; }"
            "})();"
        );
        m_view->page()->runJavaScript(js, [this](const QVariant &res){
            qInfo() << "[STYLE] pure-theme" << res;
            const QVariantMap m = res.toMap();
            if (m.value(QStringLiteral("ok")).toBool()) m_stylesOk = true;
        });
    }
    void hideCommonBanners() {
        if (!m_view || !m_view->page()) return;
        const QString js = QStringLiteral(
            "(() => {"
            "  try {"
            "    const hideTexts=['立即打开','去下载','打开App','打开 APP','下载App','App内打开','打开微信读书'];"
            "    const forceSel=["
            "      '.wr_index_page_header_download_action',"
            "      '.wr_index_page_header_download_wrapper',"
            "      '.wr_index_page_header_wrapper',"
            "      '.iget-invoke-app-bar',"
            "      '.invoke-app-btn',"
            "      '.iget-app-download',"
            "      '.download-app',"
            "      '.open-app',"
            "      '.openApp',"
            "      '.app-open',"
            "      '.wr_app_download',"
            "      '.wr_download',"
            "      '.wr_download_btn',"
            "      '.download-bar',"
            "      '.open-app-bar',"
            "      '.app-download-bar'"
            "    ];"
            "    // 精准命中微信首页下载条和得到首页的打开条\n"
            "    ['.wr_index_page_header_download_wrapper','.wr_index_page_header_download_action','.iget-invoke-app-bar','.invoke-app-btn'].forEach(sel=>{\n"
            "      document.querySelectorAll(sel).forEach(el=>{ if (el) el.style.display='none'; });\n"
            "    });"
            "    const nodes = Array.from(document.querySelectorAll('button,a,div,section'));"
            "    nodes.forEach(el => {"
            "      const t=(el.innerText||'').trim();"
            "      if(!t) return;"
            "      if(hideTexts.some(h=>t.includes(h))){"
            "        let bar = el.closest('.wr_index_page_header_download_action, .wr_index_page_header_download_wrapper, .wr_index_page_header_wrapper, .iget-invoke-app-bar, .iget-app-download, .app-open, .open-app, .openApp, .download-app, .wr_app_download, .wr_download, .wr_download_btn, .download-bar, .open-app-bar, .app-download-bar');"
            "        if (!bar) bar = el;"
            "        if (bar === document.body || bar === document.documentElement) return;"
            "        const h = bar.getBoundingClientRect ? bar.getBoundingClientRect().height : 0;"
            "        if (h===0 || h>400) return;"
            "        bar.style.display='none';"
            "      }"
            "    });"
            "    return {ok:true, hidden:true};"
            "  }catch(e){ return {ok:false, error:String(e)}; }"
            "})();"
        );
        m_view->page()->runJavaScript(js, [this](const QVariant &res){
            qInfo() << "[STYLE] banner hide" << res;
            m_bannerHidden = true;
        });
    }
    void applyBookEnhancements() {
        // 微信读书书籍页：仅施加容器占位，避免 0 高度；不改字体/分页
        if (isWeReadBook()) {
            if (!m_view || !m_view->page()) return;
            const QString js = QStringLiteral(
                "(() => {"
                "  try {"
                "    const styleId='wr-force-container';"
                "    let st=document.getElementById(styleId);"
                "    if (!st) { st=document.createElement('style'); st.id=styleId; (document.documentElement||document.body).appendChild(st); }"
                "    st.textContent = `"
                "      .renderTargetContent, iframe { min-height:100vh !important; width:100% !important; opacity:1 !important; visibility:visible !important; position:relative !important; display:block !important; }"
                "      iframe { min-height:100vh !important; width:100% !important; border:0 !important; }"
                "    `;"
            "    // 强制白色主题，确保白度判断有效，同时覆盖 iframe 内部"
            "    const applyWhite = (doc) => {"
            "      if (!doc) return;"
                "      const root = doc.documentElement || doc.body;"
                "      if (!root) return;"
                "      try {"
                "        doc.body && doc.body.classList.add('wr_whiteTheme');"
                "        doc.body && doc.body.classList.remove('wr_darkTheme');"
                "        doc.body && doc.body.setAttribute('data-theme','light');"
                "        doc.documentElement && doc.documentElement.setAttribute('data-theme','light');"
                "      } catch(_e) {}"
                "      try {"
                "        doc.cookie = 'wr_theme=white; domain=.weread.qq.com; path=/; max-age=31536000';"
                "        if (doc.defaultView && doc.defaultView.localStorage) {"
                "          doc.defaultView.localStorage.setItem('wr_theme','white');"
                "          doc.defaultView.localStorage.setItem('wrTheme','white');"
                "        }"
                "      } catch(_e) {}"
                "      let themeStyle = doc.getElementById('wr-pure-theme');"
                "      if (!themeStyle) { themeStyle = doc.createElement('style'); themeStyle.id='wr-pure-theme'; (doc.documentElement||doc.body).appendChild(themeStyle); }"
                "      if (themeStyle) {"
                "        themeStyle.textContent = `"
                "          body, html, .renderTargetContent, .renderTargetContent * { background:#ffffff !important; color:#111111 !important; text-shadow:none !important; filter:none !important; }"
                "          img, canvas, video, svg { background-color:transparent !important; filter:none !important; }"
                "        `;"
                "      }"
                "    };"
            "    applyWhite(document);"
            "    // 如果正文在 iframe 内，尝试同步主题"
            "    Array.from(document.querySelectorAll('iframe')).forEach(f => {"
            "      try {"
            "        const d = f.contentDocument || (f.contentWindow && f.contentWindow.document);"
            "        applyWhite(d);"
            "        if (d) {"
            "          const logReady = () => {"
            "            try {"
            "              const b = d.body || d.documentElement;"
            "              const r = b ? b.getBoundingClientRect() : {width:0,height:0,x:0,y:0};"
            "              const len = b && b.innerText ? b.innerText.length : 0;"
            "              console.warn('[IFRAME_READY]', JSON.stringify({src:f.src||'', rect:{x:r.x,y:r.y,w:r.width,h:r.height}, textLen: len}));"
            "            } catch(_) {}"
            "          };"
            "          d.addEventListener('DOMContentLoaded', logReady, {once:true});"
            "          d.addEventListener('load', logReady, {once:true});"
            "          d.defaultView && d.defaultView.requestAnimationFrame(() => { setTimeout(logReady, 0); });"
            "        }"
            "      } catch(_e) {}"
            "    });"
            "    return {ok:true, bodyCls:(document.body && document.body.className)||'', dataTheme:(document.body && document.body.getAttribute('data-theme'))||'', cookie:document.cookie};"
            "  } catch(e) { return {ok:false, error:String(e)}; }"
            "})()"
            );
            m_view->page()->runJavaScript(js, [](const QVariant &res){
                qInfo() << "[STYLE] wr-force-container" << res;
            });

            // 添加点击翻页功能：左侧点击上一页，右侧点击下一页
            const QString clickPagerJs = QStringLiteral(
                "(() => {"
                "  try {"
                "    const container = document.querySelector('.renderTargetContent') || document.body;"
                "    const fireClick = (btn) => {"
                "      if (!btn) return false;"
                "      const span = btn.querySelector('span') || btn;"
                "      // 模拟用户点击：pointerdown → pointerup → click"
                "      const evts = ['pointerdown','pointerup','click'];"
                "      evts.forEach(t => span.dispatchEvent(new PointerEvent(t, {bubbles:true, cancelable:true})));"
                "      return true;"
                "    };"
                "    const clickHandler = (e) => {"
                "      if (!container) return;"
                "      const rect = container.getBoundingClientRect();"
                "      const clickX = e.clientX - rect.left;"
                "      const midX = rect.width / 2;"
                "      const isLeftSide = clickX < midX;"
                "      console.log('[CLICK_PAGER]', 'x=' + Math.round(clickX) + ' width=' + Math.round(rect.width) + ' side=' + (isLeftSide ? 'left:PREV' : 'right:NEXT'));"
                "      if (isLeftSide) {"
                "        const prevBtn = document.querySelector('.renderTarget_pager_button');"
                "        fireClick(prevBtn);"
                "      } else {"
                "        const nextBtn = document.querySelector('.renderTarget_pager_button_right');"
                "        fireClick(nextBtn);"
                "      }"
                "    };"
                "    document.removeEventListener('click', window.__wereadClickPager, true);"
                "    window.__wereadClickPager = clickHandler;"
                "    document.addEventListener('click', clickHandler, true);"
                "    console.log('[CLICK_PAGER] initialized');"
                "    return {ok:true};"
                "  } catch(e) { return {ok:false, error:String(e)}; }"
                "})()"
            );
            m_view->page()->runJavaScript(clickPagerJs, [](const QVariant &res){
                qInfo() << "[CLICK_PAGER] setup result" << res;
            });
            return;
        }
        applyBookBoldIfNeeded();
        applyPureTheme();
        applyDedaoNarrow();
        installChapterObserver();
        hideCommonBanners();
    }
    void runDedaoProbe() {
        if (!m_view || !m_view->page()) return;
        const QString js = R"(
            (() => {
                try {
                    const report = { url: location.href, settingsOpened:false, themeButtons:[], fontPanel:{}, scrollables:[] };

                    const settingBtn = Array.from(document.querySelectorAll('button, [role=button]'))
                        .find(b => (b.innerText||'').trim().includes('设置') || b.classList.contains('reader-tool-button'));
                    report.hasSettingBtn = !!settingBtn;

                    const themeBtns = Array.from(document.querySelectorAll('.tool-box-theme-group .reader-tool-theme-button'));
                    report.themeButtons = themeBtns.slice(0,6).map((btn,i)=>({
                        idx:i, text:(btn.innerText||'').trim(), cls:btn.className,
                        selected:btn.classList.contains('reader-tool-theme-button-selected'),
                        visible:getComputedStyle(btn).display!=='none'
                    }));

                    const fontBox = document.querySelector('.set-tool-box-change-font');
                    const fontBtns = fontBox ? Array.from(fontBox.querySelectorAll('button')) : [];
                    report.fontPanel = { boxFound: !!fontBox, btnCount: fontBtns.length };

                    const all = document.querySelectorAll('*');
                    all.forEach(el=>{
                        if (el.scrollHeight > el.clientHeight + 20) {
                            report.scrollables.push({tag:el.tagName, cls:el.className, id:el.id, viewH:el.clientHeight, scrollH:el.scrollHeight});
                        }
                    });
                    report.scrollables = report.scrollables.slice(0,10);
                    return report;
                } catch(e) { return {error:String(e)}; }
            })()
        )";
        m_view->page()->runJavaScript(js, [](const QVariant &res){
            qInfo() << "[DEDAO_PROBE]" << res;
        });
    }
    void applyDedaoNarrow() {
        if (!m_view || !m_view->page()) return;
        if (!isDedaoBook()) return;
        const QString js = QStringLiteral(
            "(() => {"
            "  try {"
            "    let style = document.getElementById('dedao-compact');"
            "    if (!style) { style = document.createElement('style'); style.id='dedao-compact'; }"
            "    style.textContent = "
            "      'body, .reader-root, .reader, .reader-content, .iget-reader-container {'"
            "      + 'margin-left:0!important;margin-right:0!important;padding-left:0!important;padding-right:0!important;max-width:100%!important;'"
            "      + '}'"
            "      + '.reader-content, .reader, .reader-root, .iget-reader-container {width:100%!important;}';"
            "    const root = document.documentElement || document.body;"
            "    if (root && style.parentNode !== root) root.appendChild(style);"
            "  } catch(e) { return {ok:false, reason:'style', error:String(e)}; }"
            "  try {"
            "    const hideTexts=['立即打开','去下载'];"
            "    const candidates = Array.from(document.querySelectorAll('button, a, div'));"
            "    candidates.forEach(el => {"
            "      const t = (el.innerText || '').trim();"
            "      if (!t) return;"
            "      if (hideTexts.some(h => t.includes(h))) {"
            "        const bar = el.closest('.iget-app-download, .app-open, .open-app, .openApp, .download-app') || el;"
            "        bar.style.display = 'none';"
            "      }"
            "    });"
            "  } catch(e) { return {ok:false, reason:'banner', error:String(e)}; }"
            "  return {ok:true};"
            "})();"
        );
        m_view->page()->runJavaScript(js, [](const QVariant &res){
            qInfo() << "[STYLE] dedao compact" << res;
        });
    }
    void installChapterObserver() {
        if (!m_view || !m_view->page()) return;
        const bool isBook = currentUrl.toString().contains(QStringLiteral("/web/reader/"));
        if (!isBook) return;
        const QString js = QStringLiteral(
            "(() => {"
            "  if (window.__WR_OBSERVER_INSTALLED__) return {ok:true, skipped:true};"
            "  window.__WR_OBSERVER_INSTALLED__ = true;"
            "  window.__WR_CHAPTER_OBS = window.__WR_CHAPTER_OBS || {};"
            "  window.__WR_LOADFAIL = window.__WR_LOADFAIL || {active:false,retries:0,last:0};"
            "  function log(msg){ try{ console.log(msg);}catch(e){} }"
            "  function updateLocalIdx(){"
            "    try{"
            "      const m=(location.href||'').match(/reader\\/([a-zA-Z0-9]+)/);"
            "      const bid=m?m[1]:'';"
            "      const raw=localStorage.getItem('book:lastChapters');"
            "      if(raw){"
            "        const parsed=JSON.parse(raw);"
            "        if(bid && parsed && parsed[bid]!=null){"
            "          window.__WR_CHAPTER_OBS.localIdx=parseInt(parsed[bid]);"
            "          window.__WR_CHAPTER_OBS.bookId=window.__WR_CHAPTER_OBS.bookId||bid;"
            "        }"
            "      }"
            "    }catch(e){}"
            "  }"
            "  updateLocalIdx();"
            "  function checkLoadFail(){"
            "    try {"
            "      const errNode = document.querySelector('.chapterContentError, .readerError, .renderTargetContent .wr_error');"
            "      let retryBtn = null;"
            "      if (errNode){"
            "        const btns = Array.from(document.querySelectorAll('button, div[role=\"button\"], a'));"
            "        retryBtn = btns.find(b => { const t = (b.innerText||'').trim(); return t.includes('重试') || t.includes('加载失败'); });"
            "      }"
            "      if (retryBtn){"
            "        retryBtn.style.display='none';"
            "        if (!window.__WR_LOADFAIL.active){"
            "          window.__WR_LOADFAIL.active = true;"
            "          window.__WR_LOADFAIL.retries = 0;"
            "          window.__WR_LOADFAIL.start = Date.now();"
            "          log('[LOADFAIL] found');"
            "        }"
            "      } else {"
            "        if (window.__WR_LOADFAIL.active) log('[LOADFAIL] cleared');"
            "        window.__WR_LOADFAIL.active = false;"
            "      }"
            "    } catch(e) { log('[LOADFAIL] err ' + e); }"
            "  }"
            "  function doRetry(){"
            "    try {"
            "      if (!window.__WR_LOADFAIL.active) return;"
            "      const start = window.__WR_LOADFAIL.start || Date.now();"
            "      const elapsed = Date.now() - start;"
            "      if (elapsed > 120000){ log('[LOADFAIL] timeout after 2m'); window.__WR_LOADFAIL.active=false; return; }"
            "      const btn = Array.from(document.querySelectorAll('button, div[role=\"button\"], a')).find(b=> { const t=(b.innerText||'').trim(); return t.includes('重试'); });"
            "      window.__WR_LOADFAIL.retries = (window.__WR_LOADFAIL.retries||0)+1;"
            "      if (btn && btn.click){ btn.click(); log('[LOADFAIL] retry #' + window.__WR_LOADFAIL.retries + ' via click'); }"
            "      else { location.reload(); log('[LOADFAIL] retry #' + window.__WR_LOADFAIL.retries + ' via reload'); }"
            "    } catch(e) { log('[LOADFAIL] retry err ' + e); }"
            "  }"
            "  setInterval(checkLoadFail, 5000);"
            "  setInterval(doRetry, 15000);"
            "  return {ok:true, installed:true, obs: window.__WR_CHAPTER_OBS};"
            "})();"
        );
        m_view->page()->runJavaScript(js, [](const QVariant &res){
            qInfo() << "[OBS] install" << res;
        });
    }
public:
    void cycleUserAgentMode() {
        static const QStringList modes = { QStringLiteral("default"), QStringLiteral("android"), QStringLiteral("kindle") };
        static int idx = 0;
        idx = (idx + 1) % modes.size();
        const QString mode = modes.at(idx);
        // 依据模式选择 UA，并同时应用到微信/非微信页面，随后强制重载
        const QString uaDefault = m_profile ? m_profile->httpUserAgent() : QString();
        const QString kindleUA = QStringLiteral("Mozilla/5.0 (Linux; Kindle Paperwhite) AppleWebKit/537.36 (KHTML, like Gecko) Silk/3.2 Mobile Safari/537.36");
        const QString androidUA = QStringLiteral("Mozilla/5.0 (Linux; Android 14; Pixel 8) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Mobile Safari/537.36");
        const QString iosSafariUA = QStringLiteral("Mozilla/5.0 (iPhone; CPU iPhone OS 17_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1");

        QString targetUA = iosSafariUA; // default
        if (mode.compare(QStringLiteral("kindle"), Qt::CaseInsensitive) == 0) {
            targetUA = kindleUA;
        } else if (mode.compare(QStringLiteral("android"), Qt::CaseInsensitive) == 0) {
            targetUA = androidUA;
        } else if (mode.compare(QStringLiteral("default"), Qt::CaseInsensitive) == 0 && !uaDefault.isEmpty()) {
            targetUA = uaDefault;
        }

        // 记录环境变量，便于外部脚本感知
        qputenv("WEREAD_UA_MODE", mode.toUtf8());

        // 同步更新 UA 配置：微信书籍与非书籍统一使用当前模式的 UA
        m_uaNonWeRead = targetUA;
        m_uaWeReadBook = targetUA;
        m_currentUA = QStringLiteral("unset"); // 触发后续 update 生效

        // 取消待执行的抓帧，准备重载
        cancelPendingCaptures();
        m_firstFrameDone = false;
        m_reloadAttempts = 0;

        // 应用新的 UA 并强制重载当前 URL
        updateUserAgentForUrl(currentUrl);
        // 以实际生效的 UA 回填模式并更新按钮，避免误导
        m_uaMode = detectUaMode(m_profile ? m_profile->httpUserAgent() : targetUA);
        updateUaButtonText(m_uaMode);
        m_lastReloadTs = QDateTime::currentMSecsSinceEpoch();
        qInfo() << "[UA] cycle to" << m_uaMode << "UA:" << targetUA << "reload" << currentUrl << "ts" << m_lastReloadTs;
        if (m_view) {
            m_view->load(currentUrl);
        }
    }

    void updateUaButtonText(const QString &mode) {
        if (!m_uaButton) return;
        auto norm = [](const QString &m) -> QString {
            if (m.compare(QStringLiteral("android"), Qt::CaseInsensitive) == 0 ||
                m.compare(QStringLiteral("mobile"), Qt::CaseInsensitive) == 0) {
                return QStringLiteral("Mobile");
            }
            if (m.compare(QStringLiteral("kindle"), Qt::CaseInsensitive) == 0) {
                return QStringLiteral("Kindle");
            }
            if (m.compare(QStringLiteral("web"), Qt::CaseInsensitive) == 0 ||
                m.compare(QStringLiteral("desktop"), Qt::CaseInsensitive) == 0 ||
                m.compare(QStringLiteral("default"), Qt::CaseInsensitive) == 0) {
                return QStringLiteral("Web");
            }
            return m.isEmpty() ? QStringLiteral("?") : m;
        };

        const QString uaLabel = norm(mode);
        const QString bookLabel = norm(m_weReadBookMode);
        QString label = QStringLiteral("UA:%1").arg(uaLabel);
        // 对于微信书籍，优先显示当前书籍模式；若与 UA 不同则同时提示
        if (isWeReadBook()) {
            if (!bookLabel.isEmpty() && bookLabel.compare(uaLabel, Qt::CaseInsensitive) != 0) {
                label = QStringLiteral("UA:%1|Book:%2").arg(uaLabel, bookLabel);
            } else if (!bookLabel.isEmpty()) {
                label = QStringLiteral("UA:%1").arg(bookLabel);
            }
        }
        m_uaButton->setText(label);
    }

    void logUrlState(const QString &tag = QString()) {
        const QString u = currentUrl.toString();
        qInfo() << "[URL]" << tag << u
                << "isWeReadBook" << isWeReadBook()
                << "isDedao" << isDedaoBook();
    }

    // 简易探针：记录当前 URL、滚动容器和主要正文节点
    void logPageProbe(const QString &tag = QString()) {
        if (!m_view || !m_view->page()) return;
        const QString js = QStringLiteral(
            "(() => {"
            "  const url = location.href || '';"
            "  const host = location.host || '';"
            "  const path = location.pathname || '';"
            "  const cont = document.querySelector('.renderTargetContent');"
            "  const docEl = document.documentElement;"
            "  const scrollEl = document.scrollingElement || docEl || document.body;"
            "  const info = {"
            "    url, host, path,"
            "    hasRenderTarget: !!cont,"
            "    scrollElTag: scrollEl ? scrollEl.tagName : '',"
            "    scrollH: scrollEl ? scrollEl.scrollHeight : 0,"
            "    clientH: scrollEl ? scrollEl.clientHeight : 0,"
            "    offsetH: scrollEl ? scrollEl.offsetHeight : 0,"
            "  };"
            "  return info;"
            "})()"
        );
        m_view->page()->runJavaScript(js, [tag](const QVariant &v){
            qInfo() << "[PROBE]" << tag << v;
        });
    }

    // 记录当前页面脚本清单，辅助检查脚本截断/重复加载
    void logScriptInventory(bool once = true) {
        if (once && m_scriptInventoryLogged) return;
        if (!m_view || !m_view->page()) return;
        if (!isWeReadBook() && !isDedaoBook()) return;
        if (once) m_scriptInventoryLogged = true;
        const QString js = QStringLiteral(
            "(() => {"
            "  try {"
            "    const list = Array.from(document.scripts || []);"
            "    const mapped = list.map((s, idx) => ({idx, src: s.src || '', inlineLen: (s.innerText || '').length}));"
            "    console.warn('[SCRIPT_LIST]', JSON.stringify(mapped));"
            "    return mapped;"
            "  } catch(e) { return {error:String(e)}; }"
            "})()"
        );
        m_view->page()->runJavaScript(js, [](const QVariant &res){
            qInfo() << "[SCRIPT_LIST]" << res;
        });
    }

    // 记录性能资源条目，关注 app/js/css 是否加载、大小
    void logResourceEntries(bool once = true) {
        if (once && m_resourceLogged) return;
        if (!m_view || !m_view->page()) return;
        if (!isWeReadBook() && !isDedaoBook()) return;
        if (once) m_resourceLogged = true;
        const QString js = QStringLiteral(
            "(() => {"
            "  try {"
            "    const entries = performance.getEntriesByType('resource') || [];"
            "    const filtered = entries.filter(e => /app\\.|wrweb|wrwebnjlogic/i.test(e.name || ''));"
            "    const mapped = filtered.map(e => ({"
            "      name: e.name, type: e.initiatorType, transferSize: e.transferSize, encodedSize: e.encodedBodySize, decodedSize: e.decodedBodySize, dur: e.duration, respEnd: e.responseEnd"
            "    }));"
            "    console.warn('[RES_ENTRY]', JSON.stringify(mapped));"
            "    return mapped;"
            "  } catch(e) { return {error:String(e)}; }"
            "})()"
        );
        m_view->page()->runJavaScript(js, [](const QVariant &res){
            qInfo() << "[RES_ENTRY]" << res;
        });
    }

    // 全量扫描文本长度/画布/图片数量，用于判断非 DOM 文本渲染
    void logTextScan(bool once = true) {
        if (once && m_textScanDone) return;
        if (!m_view || !m_view->page()) return;
        if (!isWeReadBook() && !isDedaoBook()) return;
        if (once) m_textScanDone = true;
        const QString js = QStringLiteral(
            "(() => {"
            "  try {"
            "    const bodyLen = (document.body && document.body.innerText) ? document.body.innerText.length : 0;"
            "    let shadowText = 0;"
            "    const all = Array.from(document.querySelectorAll('*'));"
            "    let canvasCount = 0, imgCount = 0;"
            "    all.forEach(el => {"
            "      const tag = (el.tagName || '').toLowerCase();"
            "      if (tag === 'canvas') canvasCount++;"
            "      if (tag === 'img') imgCount++;"
            "      if (el.shadowRoot && el.shadowRoot.innerText) shadowText += el.shadowRoot.innerText.length;"
            "    });"
            "    let iframeText = 0; let iframeBlocked = 0; let iframeCount = 0;"
            "    Array.from(document.querySelectorAll('iframe')).forEach(f => {"
            "      iframeCount++;"
            "      try {"
            "        const d = f.contentDocument || (f.contentWindow && f.contentWindow.document);"
            "        if (d && d.body && d.body.innerText) iframeText += d.body.innerText.length;"
            "      } catch(_) { iframeBlocked++; }"
            "    });"
            "    // 也统计 renderTarget/readerChapter 节点长度，方便对比"
            "    const core = document.querySelector('.renderTargetContent') || document.querySelector('.readerChapterContent');"
            "    const coreLen = core ? ((core.innerText||'').length) : 0;"
            "    return {bodyLen, shadowText, iframeText, iframeCount, iframeBlocked, canvasCount, imgCount};"
          "  } catch(e) { return {error:String(e)}; }"
            "})()"
        );
        m_view->page()->runJavaScript(js, [](const QVariant &res){
            qWarning().noquote() << "[TEXT_SCAN]" << res;
        });
    }

    // 微信读书：滚动替代分页，步长为屏高 0.8，滚动后对齐行高
    void weReadScroll(bool forward) {
        if (!m_view || !m_view->page()) { m_navigating = false; return; }
        const int currentSeq = ++m_navSequence;
        m_navigating = true;
        const int stepPx = qRound((m_view ? m_view->height() : 1600) * (forward ? 0.8 : -0.8));
        const qint64 cppSend = QDateTime::currentMSecsSinceEpoch();
        qInfo() << "[PAGER] weRead scroll dispatch" << "forward" << forward << "step" << stepPx << "seq" << currentSeq << "ts" << cppSend;

        QTimer::singleShot(1200, this, [this, currentSeq](){
            if (m_navigating && m_navSequence == currentSeq) {
                m_navigating = false;
                qWarning() << "[PAGER] weRead force unlock (timeout 1200ms) seq" << currentSeq;
            }
        });

        const QString js = QStringLiteral(
            R"(
            (() => {
                try {
                    const t_js_start = Date.now();
                    const step = %1;
                    const el = document.querySelector('.renderTargetContent') || document.scrollingElement || document.documentElement;
                    if (!el) return {ok:false, reason:'no-container'};
                    const before = el.scrollTop || 0;
                    el.scrollBy(0, step);
                    const after = el.scrollTop || 0;
                    // 对齐到行高整数倍，减少半截行
                    const sample = el.querySelector('p, div, span');
                    const lh = sample ? parseFloat(getComputedStyle(sample).lineHeight)||32 : 32;
                    const padTop = parseFloat(getComputedStyle(el).paddingTop)||0;
                    const aligned = Math.max(0, Math.round((after - padTop)/lh)*lh + padTop);
                    if (Math.abs(aligned - after) > 0.5) el.scrollTo({top: aligned, behavior:'auto'});
                    const t_js_end = Date.now();
                    return {ok:true, before, after:aligned, delta: aligned-before, t_js_start, t_js_end, tag: el.tagName};
                } catch(e) { return {ok:false, error:String(e)}; }
            })()
            )"
        ).arg(stepPx);

        m_view->page()->runJavaScript(js, [this, cppSend, currentSeq, forward](const QVariant &res){
            const qint64 cppRecv = QDateTime::currentMSecsSinceEpoch();
            const QVariantMap m = res.toMap();
            const qint64 jsStart = m.value(QStringLiteral("t_js_start")).toLongLong();
            const qint64 jsEnd   = m.value(QStringLiteral("t_js_end")).toLongLong();
            const qint64 total   = cppRecv - cppSend;
            const qint64 queue   = jsStart ? (jsStart - cppSend) : -1;
            const qint64 exec    = (jsEnd && jsStart) ? (jsEnd - jsStart) : -1;
            const qint64 ipc     = (jsEnd) ? (cppRecv - jsEnd) : -1;
            const QString tag    = m.value(QStringLiteral("tag")).toString();
            const int delta      = m.value(QStringLiteral("delta")).toInt();

            if (total > 800) {
                qWarning().noquote() << QString("[PAGER] weRead SLOW | Total:%1ms Queue:%2ms Exec:%3ms IPC:%4ms Tag:%5 Delta:%6")
                                        .arg(total).arg(queue).arg(exec).arg(ipc).arg(tag).arg(delta);
            } else {
                qInfo().noquote() << QString("[PAGER] weRead OK   | Total:%1ms Queue:%2ms Exec:%3ms Tag:%4 Delta:%5")
                                     .arg(total).arg(queue).arg(exec).arg(tag).arg(delta);
            }
            if (isWeReadBook() && delta == 0) {
                qWarning().noquote() << QString("[PAGER] weRead scroll delta=0, fallback to pager button (%1)")
                                        .arg(forward ? QStringLiteral("next") : QStringLiteral("prev"));
                const QString clickJs = forward
                    ? QStringLiteral(
                          "(() => {"
                          "  const btn = document.querySelector('.renderTarget_pager_button_right');"
                          "  if (!btn) return {ok:false, reason:'no-next-btn'};"
                          "  const span = btn.querySelector('span') || btn;"
                          "  ['pointerdown','pointerup','click'].forEach(t=>span.dispatchEvent(new PointerEvent(t,{bubbles:true,cancelable:true})));"
                          "  return {ok:true, action:'next'};"
                          "})()")
                    : QStringLiteral(
                          "(() => {"
                          "  const btn = document.querySelector('.renderTarget_pager_button');"
                          "  if (!btn) return {ok:false, reason:'no-prev-btn'};"
                          "  const span = btn.querySelector('span') || btn;"
                          "  ['pointerdown','pointerup','click'].forEach(t=>span.dispatchEvent(new PointerEvent(t,{bubbles:true,cancelable:true})));"
                          "  return {ok:true, action:'prev'};"
                          "})()");
                m_view->page()->runJavaScript(clickJs, [forward](const QVariant &r){
                    qInfo() << "[PAGER] weRead pager fallback result"
                            << (forward ? "next" : "prev") << r;
                });
            }
            if (m_navSequence == currentSeq) {
                m_navigating = false;
            }
        });
    }
    void triggerStalledRescue(const QString &reason, int chapterLen, int bodyLen, int pollCount) {
        if (!m_view || !m_view->page() || !isWeReadBook()) return;
        m_stallRescueTriggered = true;
        const int seq = ++m_rescueSeq;
        const QString js = QStringLiteral(
            "(() => {"
            "  const btn = document.querySelector('.renderTarget_pager_button_right');"
            "  if (btn && btn.click) { btn.click(); return {ok:true, action:'click-next'}; }"
            "  location.reload();"
            "  return {ok:true, action:'reload'};"
            "})()"
        );
        m_view->page()->runJavaScript(js, [this, seq, reason, chapterLen, bodyLen, pollCount](const QVariant &res){
            qWarning() << "[RESCUE] stalled seq" << seq
                       << "reason" << reason
                       << "pollCount" << pollCount
                       << "chapterLen" << chapterLen
                       << "bodyLen" << bodyLen
                       << res;
        });
    }
};

// 会话恢复方法实现（类外实现）
void WereadBrowser::openDedaoMenu() {
    if (!isDedaoBook() || !m_view || !m_view->page()) return;
    const QString js = R"(
        (function() {
            try {
                window.scrollTo(0,0);
                const toolbar = document.querySelector('.iget-reader-toolbar');
                const btn = Array.from(toolbar ? toolbar.querySelectorAll('button,[role=button]') : [])
                    .find(b => ((b.innerText||'').includes('设置')) || (b.className||'').includes('iget-icon-font'));
                if (btn && btn.click) {
                    btn.click();
                    setTimeout(() => {
                        const panel = document.querySelector('.set-tool-box');
                        if (panel) {
                            panel.style.cssText += '; display:block !important; visibility:visible !important; opacity:1 !important;'
                                + ' z-index:99999 !important; position:fixed !important; top:15% !important; left:10% !important; width:80% !important;'
                                + ' min-width:300px !important; min-height:150px !important; background:#fff !important; border:2px solid #000 !important;';
                            console.log('[MENU_FIX] Styles forced');
                        }
                    }, 50);
                    return {ok:true, action:'clicked'};
                }
                return {ok:false, reason:'no-btn'};
            } catch(e) { return {ok:false, error:String(e)}; }
        })()
    )";
    m_view->page()->runJavaScript(js, [](const QVariant &res){
        qInfo() << "[MENU] dedao open" << res;
    });
}

QString WereadBrowser::getSessionStatePath() {
    QString dataDir = QStandardPaths::writableLocation(QStandardPaths::AppDataLocation);
    return dataDir + "/session_state.json";
}

void WereadBrowser::saveSessionState() const {
    if (!m_view || !m_view->page()) return;
    
    const QUrl url = m_view->url();
    if (url.isEmpty() || url.scheme() == "about") return;
    
    // 防抖：如果 10 秒内已保存，跳过本次保存（避免频繁写入）
    const qint64 now = QDateTime::currentMSecsSinceEpoch();
    if (m_lastSessionSaveTime > 0 && (now - m_lastSessionSaveTime) < 10000) {
        qInfo() << "[SESSION] Skip save (too soon, last save was" << (now - m_lastSessionSaveTime) << "ms ago)";
        return;
    }
    
    // 通过 JavaScript 获取滚动位置
    m_view->page()->runJavaScript(
        QStringLiteral("({url: window.location.href, scrollY: window.scrollY})"),
        [this, now](const QVariant &result) {
            QJsonObject obj = result.toJsonObject();
            QString urlStr = obj["url"].toString();
            int scrollY = obj["scrollY"].toInt();
            
            QJsonObject sessionState;
            sessionState["url"] = urlStr;
            sessionState["scrollY"] = scrollY;
            sessionState["timestamp"] = now;
            
            QString filePath = WereadBrowser::getSessionStatePath();
            QFile file(filePath);
            if (file.open(QIODevice::WriteOnly | QIODevice::Text)) {
                QJsonDocument doc(sessionState);
                file.write(doc.toJson());
                file.close();
                // 更新保存时间戳（mutable 允许在 const 方法中修改）
                m_lastSessionSaveTime = now;
                qInfo() << "[SESSION] Saved session state:" << urlStr << "scrollY:" << scrollY;
            }
        }
    );
}

QUrl WereadBrowser::loadSessionUrl() const {
    QString filePath = WereadBrowser::getSessionStatePath();
    QFile file(filePath);
    if (file.exists() && file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        QJsonDocument doc = QJsonDocument::fromJson(file.readAll());
        file.close();
        QJsonObject obj = doc.object();
        QString urlStr = obj["url"].toString();
        if (!urlStr.isEmpty()) {
            QUrl url = QUrl::fromUserInput(urlStr);
            if (url.isValid()) {
                qint64 timestamp = obj["timestamp"].toVariant().toLongLong();
                qint64 age = QDateTime::currentMSecsSinceEpoch() - timestamp;
                // 只恢复 24 小时内的会话
                if (age < 24 * 3600 * 1000) {
                    qInfo() << "[SESSION] Restoring session URL:" << url.toString() << "age:" << (age/1000) << "s";
                    return url;
                } else {
                    qInfo() << "[SESSION] Session too old, ignoring (age:" << (age/1000) << "s)";
                }
            }
        }
    }
    return QUrl();
}

int WereadBrowser::loadSessionScrollPosition() const {
    QString filePath = WereadBrowser::getSessionStatePath();
    QFile file(filePath);
    if (file.exists() && file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        QJsonDocument doc = QJsonDocument::fromJson(file.readAll());
        file.close();
        QJsonObject obj = doc.object();
        return obj["scrollY"].toInt();
    }
    return 0;
}

// KOReader 风格手势检测器：状态机驱动，区分 tap/pan/swipe/hold
// 参考: weread-test/koreader/frontend/device/gesturedetector.lua
class GestureFilter : public QObject {
    Q_OBJECT
public:
    // 手势状态机状态 (参考 KOReader Contact 状态)
    enum GestureState {
        StateIdle,      // 空闲，等待触摸
        StateTap,       // 触摸开始，等待判定 tap/pan/hold
        StatePan,       // 持续移动中（实时滚动）
        StateHold       // 长按状态
    };

    // 手势方向 (参考 KOReader getPath())
    enum Direction {
        DirNone,
        DirNorth,   // 上
        DirSouth,   // 下
        DirEast,    // 右
        DirWest     // 左
    };

    explicit GestureFilter(WereadBrowser* browser, QObject* parent = nullptr)
        : QObject(parent), m_browser(browser), m_windowHeight(1696) {
        // Hold 定时器：500ms 后触发长按 (参考 KOReader HOLD_INTERVAL_MS = 500)
        m_holdTimer.setSingleShot(true);
        m_holdTimer.setInterval(HOLD_INTERVAL_MS);
        connect(&m_holdTimer, &QTimer::timeout, this, &GestureFilter::onHoldTimeout);
    }
    
    void setWindowHeight(int height) {
        m_windowHeight = height;
        qInfo() << "[GESTURE] Window height set to" << m_windowHeight;
    }

protected:
    bool eventFilter(QObject* obj, QEvent* ev) override {
        if (!m_browser) {
            qWarning() << "[GESTURE_DEBUG] eventFilter: m_browser is null, event type" << ev->type();
            return QObject::eventFilter(obj, ev);
        }

        // 检查事件目标是否是菜单或菜单的子控件 - 如果是，拦截事件，防止传递到页面
        QWidget* widget = qobject_cast<QWidget*>(obj);
        if (widget) {
            // 通过对象名检查：菜单设置了 objectName="weread_menu_overlay"
            QWidget* check = widget;
            while (check) {
                if (check->objectName() == QStringLiteral("weread_menu_overlay")) {
                    // 对于触摸和鼠标事件，拦截它们，防止传递到页面导致翻页
                    // 注意：返回 false 让事件正常传递给菜单按钮，但不会传递到页面（因为菜单在页面上层）
                    // 如果返回 true，菜单按钮可能收不到事件
                    if (ev->type() == QEvent::TouchBegin || ev->type() == QEvent::TouchUpdate || 
                        ev->type() == QEvent::TouchEnd || ev->type() == QEvent::MouseButtonPress ||
                        ev->type() == QEvent::MouseButtonRelease || ev->type() == QEvent::MouseMove) {
                        qInfo() << "[GESTURE] Event on menu widget, allowing to menu button (not to page), obj=" << obj->metaObject()->className() << "type=" << ev->type();
                        // 返回 false 让事件传递给菜单按钮，但由于菜单在页面上层，事件不会传递到页面
                        return false;
                    }
                    // 其他事件（如绘制、焦点等）正常传递
                    return false;
                }
                check = check->parentWidget();
            }
        }
        
        // 检查是否在书籍页面
        const bool isWeReadBook = m_browser->isWeReadBook();
        const bool isDedaoBook = m_browser->isDedaoBook();
        const bool isBookPage = isWeReadBook || isDedaoBook;
        
        // 如果事件不是发生在菜单控件上，但在书籍页面，检查事件位置是否在菜单区域内
        // 如果位置在菜单区域内且菜单可见，让事件传递给菜单（不拦截）
        // 如果位置在菜单区域内但菜单不可见，拦截事件防止页面翻页
        if (isBookPage && !widget && (ev->type() == QEvent::TouchBegin || ev->type() == QEvent::TouchEnd || 
            ev->type() == QEvent::MouseButtonPress || ev->type() == QEvent::MouseButtonRelease)) {
            QPointF pos;
            bool hasPos = false;
            if (ev->type() == QEvent::TouchBegin || ev->type() == QEvent::TouchEnd) {
                auto *te = static_cast<QTouchEvent*>(ev);
                if (!te->points().isEmpty()) {
                    pos = te->points().first().position();
                    hasPos = true;
                }
            } else {
                auto *me = static_cast<QMouseEvent*>(ev);
                pos = me->position();
                hasPos = true;
            }
            
            // 检查点击位置是否在菜单区域内（菜单在 y=70, height=100）
            if (hasPos && pos.y() >= 70 && pos.y() <= 170) {
                // 如果位置在菜单区域内，不拦截事件，让 Qt 事件系统正常处理
                // 如果菜单可见，事件会被菜单接收；如果菜单不可见，事件可能会传递到页面
                // 但由于菜单在页面上层（通过 raise()），如果菜单可见，事件应该会被菜单接收
                qInfo() << "[GESTURE] Touch/click in menu area, allowing event to pass (menu will receive if visible), pos=" << pos;
                return false;  // 不拦截，让事件正常传递（菜单在页面上层，会优先接收）
            }
        }
        
        // 底部向上滑动退出手势在所有页面都生效，其他手势只在书籍页面生效
        // 对于非书籍页面，我们需要处理触摸事件以检测底部向上滑动，但其他手势不拦截

        // 调试日志：记录所有触摸/鼠标事件
        if (ev->type() == QEvent::MouseButtonPress || ev->type() == QEvent::MouseButtonRelease ||
            ev->type() == QEvent::MouseMove || ev->type() == QEvent::TouchBegin ||
            ev->type() == QEvent::TouchUpdate || ev->type() == QEvent::TouchEnd) {
            QString eventTypeStr;
            QPointF pos;
            if (ev->type() == QEvent::MouseButtonPress || ev->type() == QEvent::MouseButtonRelease ||
                ev->type() == QEvent::MouseMove) {
                auto *me = static_cast<QMouseEvent*>(ev);
                eventTypeStr = (ev->type() == QEvent::MouseButtonPress ? "MousePress" :
                               ev->type() == QEvent::MouseButtonRelease ? "MouseRelease" : "MouseMove");
                pos = me->position();
            } else {
                auto *te = static_cast<QTouchEvent*>(ev);
                eventTypeStr = (ev->type() == QEvent::TouchBegin ? "TouchBegin" :
                               ev->type() == QEvent::TouchUpdate ? "TouchUpdate" : "TouchEnd");
                if (!te->points().isEmpty()) {
                    pos = te->points().first().position();
                }
            }
            qInfo() << "[GESTURE_DEBUG] eventFilter received" << eventTypeStr << "pos" << pos
                    << "obj" << (obj ? obj->metaObject()->className() : "null")
                    << "isWeReadKindleMode" << (m_browser ? m_browser->isWeReadKindleMode() : false)
                    << "isBookPage" << isBookPage;
        }

        // 处理触摸/鼠标事件
        bool handled = false;
        switch (ev->type()) {
        case QEvent::MouseButtonPress: {
            auto *me = static_cast<QMouseEvent*>(ev);
            if (isBookPage) {
                handled = handleContactDown(me->position());
            } else {
                // 非书籍页面：完全不处理，让事件直接传递给 WebEngine
                handled = false;  // 让事件继续传递
            }
            break;
        }
        case QEvent::MouseMove: {
            auto *me = static_cast<QMouseEvent*>(ev);
            if (isBookPage) {
                handled = handleContactMove(me->position(), isBookPage);
            } else {
                // 非书籍页面：完全不处理，让事件直接传递给 WebEngine
                handled = false;  // 让事件继续传递
            }
            break;
        }
        case QEvent::MouseButtonRelease: {
            auto *me = static_cast<QMouseEvent*>(ev);
            if (isBookPage) {
                handled = handleContactUp(me->position(), isBookPage);
            } else {
                // 非书籍页面：完全不处理，让事件直接传递给 WebEngine
                handled = false;  // 让事件继续传递
            }
            break;
        }
        case QEvent::TouchBegin: {
            auto *te = static_cast<QTouchEvent*>(ev);
            if (te->points().isEmpty()) return true;
            if (isBookPage) {
                handled = handleContactDown(te->points().first().position());
            } else {
                // 非书籍页面：完全不处理，让事件直接传递给 WebEngine
                handled = false;  // 让事件继续传递
            }
            break;
        }
        case QEvent::TouchUpdate: {
            auto *te = static_cast<QTouchEvent*>(ev);
            if (te->points().isEmpty()) return true;
            if (isBookPage) {
                handled = handleContactMove(te->points().first().position(), isBookPage);
            } else {
                // 非书籍页面：完全不处理，让事件直接传递给 WebEngine
                handled = false;  // 让事件继续传递
            }
            break;
        }
        case QEvent::TouchEnd: {
            auto *te = static_cast<QTouchEvent*>(ev);
            if (te->points().isEmpty()) return true;
            if (isBookPage) {
                handled = handleContactUp(te->points().first().position(), isBookPage);
            } else {
                // 非书籍页面：完全不处理，让事件直接传递给 WebEngine
                handled = false;  // 让事件继续传递
            }
            break;
        }
        default:
            break;
        }
        
        // 对于非书籍页面，直接返回 false，让事件正常传递给 WebEngine
        // 对于书籍页面，返回 handled 的值（true=拦截，false=传递）
        if (!isBookPage) {
            return false;  // 不拦截，让事件传递给目标对象（WebEngine）
        }
        
        return handled;  // 书籍页面：根据手势处理结果决定是否拦截
    }

private slots:
    void onHoldTimeout() {
        if (m_state == StateTap) {
            // 从 tap 状态转换到 hold 状态 (参考 KOReader holdState)
            m_state = StateHold;
            qInfo() << "[GESTURE] hold detected @" << m_startPos;
            // TODO: 可以在这里触发长按菜单等操作
        }
    }

private:
    // ==================== KOReader 风格参数 ====================
    // 时间参数 (ms) - 参考 gesturedetector.lua
    static constexpr qint64 TAP_INTERVAL_MS = 0;           // tap 防抖（我们不需要）
    static constexpr qint64 DOUBLE_TAP_INTERVAL_MS = 300;  // 双击间隔
    static constexpr qint64 HOLD_INTERVAL_MS = 500;        // 长按阈值
    static constexpr qint64 SWIPE_INTERVAL_MS = 900;       // 滑动必须在此时间内完成

    // 距离参数 (像素) - 参考 gesturedetector.lua scaleByDPI
    // reMarkable Paper Pro DPI ≈ 226, 35 DPI ≈ 35 * (226/160) ≈ 49 px
    static constexpr qreal PAN_THRESHOLD = 50.0;           // pan 触发阈值
    static constexpr qreal TAP_BOUNCE_DISTANCE = 40.0;     // tap 抖动容差
    static constexpr qreal SWIPE_MIN_DISTANCE = 100.0;     // swipe 最小距离

    // ==================== 状态机核心处理 ====================

    // 触摸开始 (参考 KOReader Contact:initialState -> tapState)
    bool handleContactDown(const QPointF& pos) {
        // 如果触摸位置在菜单区域内（y=70-170），不处理，让事件传递给菜单
        if (pos.y() >= 70 && pos.y() <= 170) {
            qInfo() << "[GESTURE] contact down in menu area, skipping gesture handling, pos=" << pos;
            return false;  // 不处理，让事件传递给菜单
        }
        
        m_state = StateTap;
        m_startPos = pos;
        m_currentPos = pos;
        m_panAccumulated = QPointF(0, 0);
        m_timer.restart();
        m_timer.start();
        m_holdTimer.start();  // 开始计时长按
        qInfo() << "[GESTURE] contact down @" << pos << "state -> StateTap";
        return true;
    }

    // 触摸移动 (参考 KOReader Contact:handleNonTap -> panState)
    // isBookPage: true=书籍页面（处理滚动），false=非书籍页面（只记录状态）
    bool handleContactMove(const QPointF& pos, bool isBookPage = true) {
        if (m_state == StateIdle) return true;

        m_currentPos = pos;
        const qreal dx = pos.x() - m_startPos.x();
        const qreal dy = pos.y() - m_startPos.y();
        const qreal absDx = qAbs(dx);
        const qreal absDy = qAbs(dy);

        // 在 StateTap 状态下，检测是否移动超过阈值 -> 转为 Pan
        if (m_state == StateTap) {
            if (absDx >= PAN_THRESHOLD || absDy >= PAN_THRESHOLD) {
                // 停止长按定时器，切换到 pan 状态
                m_holdTimer.stop();
                m_state = StatePan;
                m_panStartPos = m_startPos;  // 记录 pan 起始点
                qInfo() << "[GESTURE] state -> StatePan, moved" << absDx << absDy;
            }
        }

        // 在 StatePan 状态下，实时处理滚动 (参考 KOReader handlePan)
        // 注意：只在书籍页面执行滚动，非书籍页面让 WebEngine 自己处理
        if (m_state == StatePan && isBookPage) {
            Direction dir = getDirection(dx, dy);
            // 垂直方向：实时滚动
            if (dir == DirNorth || dir == DirSouth) {
                // 计算增量滚动（相对于上次位置）
                const qreal deltaY = pos.y() - m_lastPanPos.y();
                if (qAbs(deltaY) > 5.0) {  // 最小增量阈值
                    m_browser->scrollByJs(static_cast<int>(deltaY));
                    m_panAccumulated.ry() += deltaY;
                    m_lastPanPos = pos;
                    qInfo() << "[GESTURE] pan scroll deltaY" << deltaY << "total" << m_panAccumulated.y();
                }
            }
            // 水平方向：暂不实时处理，等 swipe 判定
        } else if (m_state == StatePan && !isBookPage) {
            // 非书籍页面：只更新位置，不执行滚动
            m_lastPanPos = pos;
        }

        // 在 StateHold 状态下，检测是否开始 hold_pan
        if (m_state == StateHold) {
            if (absDx >= PAN_THRESHOLD || absDy >= PAN_THRESHOLD) {
                // hold_pan 模式：长按后拖动
                qInfo() << "[GESTURE] hold_pan detected";
                // TODO: 实现 hold_pan 操作（如选择文本）
            }
        }

        return true;
    }

    // 触摸结束 (参考 KOReader tapState/panState 的 contact lift 处理)
    // isBookPage: true=书籍页面（处理所有手势），false=非书籍页面（只处理底部向上滑动退出）
    bool handleContactUp(const QPointF& pos, bool isBookPage = true) {
        m_holdTimer.stop();
        
        // 如果触摸位置在菜单区域内（y=70-170），不处理，让事件传递给菜单
        if (pos.y() >= 70 && pos.y() <= 170) {
            qInfo() << "[GESTURE] contact up in menu area, skipping gesture handling, pos=" << pos;
            m_state = StateIdle;  // 重置状态
            return false;  // 不处理，让事件传递给菜单
        }

        if (m_state == StateIdle) return true;

        m_currentPos = pos;
        const qreal dx = pos.x() - m_startPos.x();
        const qreal dy = pos.y() - m_startPos.y();
        const qreal absDx = qAbs(dx);
        const qreal absDy = qAbs(dy);
        const qint64 ms = m_timer.isValid() ? m_timer.elapsed() : 0;
        const qreal distance = qSqrt(dx*dx + dy*dy);
        Direction dir = getDirection(dx, dy);

        qInfo() << "[GESTURE] contact up @" << pos << "state" << m_state
                << "dx" << dx << "dy" << dy << "ms" << ms << "dir" << directionName(dir)
                << "isBookPage" << isBookPage;

        // ==================== 手势判定逻辑 ====================
        
        // 底部上滑退出：从屏幕底部边缘外（或非常接近底部边缘）上滑，在所有页面都生效（优先级最高）
        if (m_state == StatePan && dir == DirNorth) {
            // 从屏幕底部边缘外开始：起始位置在底部20像素内（y >= 1676，窗口高度1696）
            const qreal bottomEdgeThreshold = m_windowHeight - 20.0;  // 底部20像素区域（接近屏幕外）
            const bool fromBottomEdge = m_startPos.y() >= bottomEdgeThreshold;
            if (fromBottomEdge && ms < SWIPE_INTERVAL_MS && absDy >= SWIPE_MIN_DISTANCE) {
                qInfo() << "[GESTURE] bottom edge swipe up detected -> exit app (startY=" << m_startPos.y() 
                        << "windowHeight=" << m_windowHeight << "dy=" << dy << "ms=" << ms << ")";
                if (m_browser) {
                    // 先保存会话状态
                    m_browser->saveSessionState();
                    // 然后退出
                    m_browser->exitToXochitl();
                }
                m_state = StateIdle;
                return true;  // 已处理，拦截事件
            }
        }
        
        // 右侧边缘外左滑全刷：从屏幕右侧边缘外（或非常接近右侧边缘）左滑至少200px，在所有页面都生效（用于手动清理残影）
        if (m_state == StatePan && dir == DirWest) {
            // 窗口宽度是954像素，右侧边缘外：起始位置在右侧20像素内（x >= 934）
            const qreal windowWidth = 954.0;  // 固定窗口宽度
            const qreal rightEdgeThreshold = windowWidth - 20.0;  // 右侧20像素区域（接近屏幕外）
            const bool fromRightEdge = m_startPos.x() >= rightEdgeThreshold;
            const qreal minSwipeDistance = 200.0;  // 至少左滑200像素
            if (fromRightEdge && ms < SWIPE_INTERVAL_MS && absDx >= minSwipeDistance) {
                qInfo() << "[GESTURE] right edge swipe left detected -> full refresh (startX=" << m_startPos.x() 
                        << "windowWidth=" << windowWidth << "dx=" << dx << "absDx=" << absDx << "ms=" << ms << ")";
                if (m_browser) {
                    m_browser->triggerFullRefresh();
                }
                m_state = StateIdle;
                return true;  // 已处理，拦截事件
            }
        }
        
        // 对于非书籍页面，不拦截其他手势，让事件正常传递给 WebEngine
        // WebEngine 会自动将触摸事件转换为鼠标事件
        if (!isBookPage) {
            m_state = StateIdle;
            return false;  // 不拦截，让事件正常传递
        }

        // 书籍页面：处理所有手势
        if (m_state == StateTap) {
            // 在 tap 状态释放 -> 判定为 tap (参考 KOReader handleDoubleTap)
            if (absDx < TAP_BOUNCE_DISTANCE && absDy < TAP_BOUNCE_DISTANCE) {
                // Kindle 模式的微信书籍页：tap 直接触发下一页按钮
                const bool isKindleMode = m_browser ? m_browser->isWeReadKindleMode() : false;
                const bool isWeReadBook = m_browser ? m_browser->isWeReadBook() : false;
                const bool isKindleUA = m_browser ? m_browser->isKindleUA() : false;
                qInfo() << "[GESTURE_DEBUG] tap check: isWeReadKindleMode" << isKindleMode
                        << "isWeReadBook" << isWeReadBook << "isKindleUA" << isKindleUA
                        << "absDx" << absDx << "absDy" << absDy << "TAP_BOUNCE_DISTANCE" << TAP_BOUNCE_DISTANCE;
                if (m_browser && isKindleMode) {
                    const qint64 tapTime = QDateTime::currentMSecsSinceEpoch();
                    qInfo() << "[GESTURE] tap -> next (weRead kindle mode) timestamp" << tapTime;
                    m_browser->goNextPage();
                    return true;
                } else {
                    qInfo() << "[GESTURE] tap detected @" << pos << "-> inject mouse click";
                    m_browser->injectMouse(Qt::LeftButton, QEvent::MouseButtonPress, pos);
                    m_browser->injectMouse(Qt::LeftButton, QEvent::MouseButtonRelease, pos);
                    return true;
                }
            } else {
                qInfo() << "[GESTURE_DEBUG] tap rejected: movement too large, absDx" << absDx << "absDy" << absDy;
                return false;
            }
        }
        else if (m_state == StatePan) {
            // 在 pan 状态释放 -> 判定是 swipe 还是 pan_release
            // 参考 KOReader: isSwipe() 检查时间 < SWIPE_INTERVAL_MS
            if (ms < SWIPE_INTERVAL_MS && distance >= SWIPE_MIN_DISTANCE) {
                // 快速滑动 -> Swipe (参考 KOReader handleSwipe)
                if (dir == DirWest) {
                    // 左滑 -> 下一页
                    qInfo() << "[GESTURE] swipe west -> next page";
                    m_browser->goNextPage();
                    return true;
                }
                else if (dir == DirEast) {
                    // 右滑：区分边缘退出 vs 上一页
                    const bool edgeSwipe = m_startPos.x() < 60.0; // 屏幕左缘外/近缘
                    if (edgeSwipe && m_browser && m_browser->isWeReadBook()) {
                        qInfo() << "[GESTURE] edge swipe east -> exit book";
                        m_browser->goBack();
                        return true;
                    } else {
                        qInfo() << "[GESTURE] swipe east -> prev page";
                        m_browser->goPrevPage();
                        return true;
                    }
                }
                else if (dir == DirSouth) {
                    // 顶部下滑 -> 呼出菜单（优先级高于滚动）
                    const bool fromTop = m_startPos.y() < 180.0;  // 顶部阈值
                    if (fromTop && dy > 80.0 && ms < 1500) {
                        qInfo() << "[GESTURE] top pull-down detected, show menu (startY=" << m_startPos.y() << "dy=" << dy << "ms=" << ms << ")";
                        if (m_browser) {
                            m_browser->showMenu();
                            m_browser->scheduleBookCaptures();
                        }
                        m_state = StateIdle;
                        return true;  // 已处理，拦截事件
                    }
                    // 非顶部下滑：已经在 pan 中实时处理了滚动
                    qInfo() << "[GESTURE] swipe south -> pan already handled, total scroll" << m_panAccumulated.y();
                    return true;  // 已处理，拦截事件
                }
                else if (dir == DirNorth) {
                    // 上滑 -> 已经在 pan 中实时处理了滚动
                    qInfo() << "[GESTURE] swipe north -> pan already handled, total scroll" << m_panAccumulated.y();
                    return true;  // 已处理，拦截事件
                }
            }
            else {
                // 慢速移动 -> pan_release (参考 KOReader handlePanRelease)
                // 检查是否是顶部下滑手势（即使是慢速移动也应该能呼出菜单）
                const bool fromTop = m_startPos.y() < 180.0;  // 顶部阈值
                if (fromTop && dir == DirSouth && dy > 80.0 && ms < 1500) {
                    qInfo() << "[GESTURE] slow top pull-down detected, show menu (startY=" << m_startPos.y() << "dy=" << dy << "ms=" << ms << ")";
                    if (m_browser) {
                        m_browser->showMenu();
                        m_browser->scheduleBookCaptures();
                    }
                    m_state = StateIdle;
                    return true;  // 已处理，拦截事件
                }
                qInfo() << "[GESTURE] pan_release, total scroll" << m_panAccumulated.y();
                // 垂直 pan 已经实时处理，无需额外操作
                return true;  // 已处理，拦截事件
            }
        }
        else if (m_state == StateHold) {
            // 长按释放 (参考 KOReader hold_release)
            qInfo() << "[GESTURE] hold_release @" << pos;
            // TODO: 可以在这里处理长按释放后的操作
        }

        // 重置状态
        m_state = StateIdle;
        m_lastPanPos = m_startPos;  // 重置 pan 位置
        return true;
    }

    // ==================== 辅助函数 ====================

    // 计算方向 (参考 KOReader Contact:getPath)
    Direction getDirection(qreal dx, qreal dy) const {
        if (dx == 0 && dy == 0) return DirNone;
        // 简化版：只判断主方向（不含对角线）
        if (qAbs(dx) > qAbs(dy)) {
            return dx < 0 ? DirWest : DirEast;
        } else {
            return dy < 0 ? DirNorth : DirSouth;
        }
    }

    // 方向名称（调试用）
    static const char* directionName(Direction dir) {
        switch (dir) {
        case DirNone:  return "none";
        case DirNorth: return "north";
        case DirSouth: return "south";
        case DirEast:  return "east";
        case DirWest:  return "west";
        }
        return "unknown";
    }

    // ==================== 成员变量 ====================
    WereadBrowser* m_browser = nullptr;
    int m_windowHeight = 1696;  // 窗口高度（用于判断底部区域）

    // 状态机
    GestureState m_state = StateIdle;

    // 触摸坐标
    QPointF m_startPos;         // 触摸起始点
    QPointF m_currentPos;       // 当前位置
    QPointF m_panStartPos;      // pan 开始位置
    QPointF m_lastPanPos;       // 上次 pan 位置（用于增量滚动）
    QPointF m_panAccumulated;   // pan 累计位移

    // 定时器
    QElapsedTimer m_timer;      // 手势时长计时
    QTimer m_holdTimer;         // 长按定时器
};

// GlobalInputLogger 已移除：所有功能已由 GestureFilter 统一处理
// - 菜单检查：GestureFilter 已实现
// - 滚动刷新：GestureFilter 通过 scrollByJs() 触发，由 SmartRefreshManager 处理
// - 顶部下滑菜单：GestureFilter 已实现
// 移除后减少一个事件过滤器，节省资源

    class TouchBridge : public QObject {
        Q_OBJECT
    public:
        explicit TouchBridge(WereadBrowser* browser, QObject* parent = nullptr)
            : QObject(parent), m_browser(browser) {
            const QHostAddress bindAddr(QStringLiteral("127.0.0.1"));
            const bool ok = m_socket.bind(bindAddr, 45454,
                                          QUdpSocket::ShareAddress | QUdpSocket::ReuseAddressHint);
            qInfo() << "[TOUCH] bind" << ok << "addr" << bindAddr.toString() << "port" << 45454;
            connect(&m_socket, &QUdpSocket::readyRead, this, &TouchBridge::onReady);
        }
    private slots:
        void onReady() {
            while (m_socket.hasPendingDatagrams()) {
                QByteArray datagram;
                datagram.resize(int(m_socket.pendingDatagramSize()));
                m_socket.readDatagram(datagram.data(), datagram.size());
                if (datagram.size() < int(sizeof(Payload))) continue;
                Payload p;
                memcpy(&p, datagram.constData(), sizeof(Payload));
                QPointF pt(p.x, p.y);
                const qint64 tsMs = QDateTime::currentMSecsSinceEpoch();
                m_lastTouchMs = tsMs;
                qInfo() << "[TOUCH_BRIDGE] type" << p.type << "pos" << pt << "ts" << tsMs;
                if (m_browser) m_browser->updateLastTouchTs(tsMs);
                // 恢复原装行为
                switch (p.type) {
                case 101: m_browser->exitToXochitl(); break;
                case 102: m_browser->allowDedaoDetailOnce(); m_browser->goBack(); m_browser->scheduleBookCaptures(); break;
                case 103: m_browser->goNextPage(); break;
                case 104: m_browser->goPrevPage(); break;
                case 105: m_browser->injectWheel(pt, -120); m_browser->scrollByJs(-m_browser->pageStep()); break;
                case 106: m_browser->injectWheel(pt, 120); m_browser->scrollByJs(m_browser->pageStep()); break;
                case 107: m_browser->showMenu(); m_browser->scheduleBookCaptures(); break;
                case 108: m_browser->toggleTheme(); m_browser->scheduleBookCaptures(); break;
                case 112: m_browser->toggleService(); m_browser->scheduleBookCaptures(); break;
                case 109: m_browser->adjustFont(true); m_browser->scheduleBookCaptures(); break;
                case 110: m_browser->adjustFont(false); m_browser->scheduleBookCaptures(); break;
                case 111: m_browser->cycleUserAgentMode(); m_browser->scheduleBookCaptures(); break;
                case 1:
                    m_lastPos = pt; m_pressed = true;
                    m_browser->injectMouse(Qt::LeftButton, QEvent::MouseButtonPress, pt);
                    m_pressTimer.restart();
                    break;
                case 2:
                    if (!m_pressed) { m_browser->injectMouse(Qt::LeftButton, QEvent::MouseButtonPress, pt); m_pressed = true; }
                    if (m_lastPos.isNull()) m_lastPos = pt;
                    m_accumDy += int(pt.y() - m_lastPos.y());
                    m_lastPos = pt;
                    m_browser->injectMouse(Qt::LeftButton, QEvent::MouseMove, pt);
                    break;
                case 3: {
                    if (!m_pressed) {
                        m_browser->injectMouse(Qt::LeftButton, QEvent::MouseButtonPress, pt);
                    }
                    m_browser->injectMouse(Qt::LeftButton, QEvent::MouseButtonRelease, pt);
                    const qint64 pressMs = m_pressTimer.isValid() ? m_pressTimer.elapsed() : 0;
                    const bool longPress = pressMs > 500;
                    if (longPress || std::abs(m_accumDy) <= 5) {
                        if (m_browser->isDedaoBook()) {
                            m_browser->openDedaoMenu();
                            QWebEngineView* v = m_browser->getView();
                            if (v && v->page()) checkMenuPanelState(v->page());
                        } else {
                            m_browser->hittestJs(pt);
                        }
                    } else {
                        m_browser->injectWheel(pt, -m_accumDy);
                        m_browser->scrollByJs(m_accumDy);
                    }
                    m_browser->restartCaptureLoop();
                    m_accumDy = 0;
                    m_lastPos = QPointF();
                    m_pressed = false;
                    break;
                }
                default: break;
                }
            }
        }
    private:
        struct Payload { quint8 type; quint8 pad[3]; float x; float y; };
        QUdpSocket m_socket;
        WereadBrowser* m_browser = nullptr;
        QPointF m_lastPos;
        int m_accumDy = 0;
        bool m_pressed = false;
        QElapsedTimer m_pressTimer;
        qint64 m_lastTouchMs = 0;
    };

int main(int argc, char* argv[]) {
    g_prevHandler = qInstallMessageHandler(filteredMessageHandler);
    qSetMessagePattern(QStringLiteral("%{time yyyy-MM-dd hh:mm:ss.zzz} [%{type}] %{message}"));
    auto ensureEnv = [](const char* name, const QByteArray& value) {
        if (!qEnvironmentVariableIsSet(name) || qEnvironmentVariable(name).isEmpty())
            qputenv(name, value);
    };
    // 整合方案：使用 linuxfb/epaper 平台直接输出，不再用 offscreen + 共享内存
    // 优先使用启动脚本设置的 QT_QPA_PLATFORM（如 linuxfb:fb=/dev/fb0:size=954x1696:depth=16）
    // 如需回退到旧方案，设置环境变量 QT_QPA_PLATFORM=offscreen
    ensureEnv("QT_QPA_PLATFORM", QByteArrayLiteral("linuxfb"));
    ensureEnv("QTWEBENGINE_DISABLE_SANDBOX", QByteArrayLiteral("1"));
    // 开启 Qt 输入日志，便于触摸排查
    ensureEnv("QT_LOGGING_RULES", QByteArrayLiteral("qt.qpa.input=true;qt.qpa.events=true;qt.qpa.touch=true;qt.qpa.evdev=true"));
    // 开启 Qt 输入日志，便于触摸排查（若外部已设置则尊重外部）
    ensureEnv("QT_LOGGING_RULES", QByteArrayLiteral("qt.qpa.input=true;qt.qpa.events=true;qt.qpa.touch=true;qt.qpa.evdev=true"));
    // 强制设置 Chromium flags，避免启动脚本未传递导致缺失
    // 方案E优化：启用HTTP缓存、HTTP/2、Brotli压缩，增加渲染线程数
    QByteArray chromiumFlags =
        QByteArrayLiteral("--disable-gpu --disable-gpu-compositing "
                          "--disable-webgl --disable-accelerated-video-decode "
                          "--disable-smooth-scrolling --num-raster-threads=6 "
                          "--no-sandbox --touch-events=enabled "
                          "--disk-cache-size=524288000 "  // 500MB (原50MB增大10倍)
                          "--enable-features=NetworkServiceInProcess");
    // A/B 测试 2D Canvas：默认尝试启用加速，可通过环境变量关闭
    if (qEnvironmentVariableIsSet("WEREAD_DISABLE_ACCEL_2D")) {
        chromiumFlags.append(" --disable-accelerated-2d-canvas");
        qInfo() << "[ENV] 2D canvas accel disabled (WEREAD_DISABLE_ACCEL_2D)";
    } else {
        chromiumFlags.append(" --enable-accelerated-2d-canvas");
        qInfo() << "[ENV] 2D canvas accel enabled (default, set WEREAD_DISABLE_ACCEL_2D to disable)";
    }
    qputenv("QTWEBENGINE_CHROMIUM_FLAGS", chromiumFlags);
    qInfo() << "[ENV] QTWEBENGINE_CHROMIUM_FLAGS" << qgetenv("QTWEBENGINE_CHROMIUM_FLAGS");
    QCoreApplication::setAttribute(Qt::AA_SynthesizeMouseForUnhandledTouchEvents);
    QCoreApplication::setAttribute(Qt::AA_SynthesizeTouchForUnhandledMouseEvents);
    QApplication app(argc, argv);
    QCoreApplication::setOrganizationName("weread-lab");
    QCoreApplication::setApplicationName("weread-browser");
    // 整合方案：移除 ShmFrameWriter，不再写共享内存
    // 显示由 epaper 平台直接输出到 fb0，由 appload shim 拦截并刷新
    // ShmFrameWriter writer;
    // writer.init("/dev/shm/weread_frame");
    FbRefreshHelper fbRef; // 简单刷新帮助器：启动后做一次全屏刷新
    // Resolve start URL: saved session > env override > CLI arg > default shelf
    const QByteArray envUrl = qgetenv("WEREAD_URL");
    QUrl startUrl;
    
    // 尝试加载保存的会话 URL（如果存在且有效）
    QUrl sessionUrl;
    {
        // 创建临时实例以加载会话状态
        WereadBrowser tempBrowser(QUrl("about:blank"), nullptr);
        sessionUrl = tempBrowser.loadSessionUrl();
    }
    
    if (qEnvironmentVariableIsSet("WEREAD_START_BLANK")) {
        startUrl = QUrl(QStringLiteral("about:blank"));
    } else if (!envUrl.isEmpty()) {
        startUrl = QUrl::fromUserInput(QString::fromLocal8Bit(envUrl));
    } else if (argc > 1) {
        startUrl = QUrl::fromUserInput(QString::fromLocal8Bit(argv[1]));
    } else if (sessionUrl.isValid()) {
        startUrl = sessionUrl;  // 使用保存的会话 URL
        qInfo() << "[WEREAD] Restoring session URL:" << startUrl.toString();
    } else {
        startUrl = QUrl(QStringLiteral("https://weread.qq.com/"));
    }
    qInfo() << "[WEREAD] Starting with URL:" << startUrl.toString();
    // 一体化方案：无需后端 viewer
    WereadBrowser window(startUrl, &fbRef);
    
    // 如果恢复了会话 URL，也恢复滚动位置
    if (sessionUrl.isValid()) {
        window.m_restoredScrollY = window.loadSessionScrollPosition();
        window.m_isRestoringSession = true;
        if (window.m_restoredScrollY > 0) {
            qInfo() << "[SESSION] Will restore scroll position:" << window.m_restoredScrollY;
        }
    }
    // 整合方案：移除 TouchBridge（后端 UDP 手势转发不再需要）
    // 触摸事件由 Qt epaper 平台直接传递给 WebEngine
    // TouchBridge bridge(&window);
    
    // GlobalInputLogger 已移除，所有功能由 GestureFilter 统一处理
    
    // 安装 KOReader 风格手势过滤器（状态机驱动，区分 tap/pan/swipe/hold）
    // 在应用级别安装，确保能够捕获所有触摸/鼠标事件（后安装的过滤器会先被调用）
    GestureFilter* appGestureFilter = new GestureFilter(&window, &app);
    app.installEventFilter(appGestureFilter);
    qInfo() << "[GESTURE] KOReader-style GestureFilter installed at application level";
    
    // 同时在 view 级别也安装（作为备用，处理可能遗漏的事件）
    if (window.view()) {
        GestureFilter* viewGestureFilter = new GestureFilter(&window, &window);
        window.view()->installEventFilter(viewGestureFilter);
        qInfo() << "[GESTURE] KOReader-style GestureFilter also installed on WebEngineView (backup)";
    } else {
        qWarning() << "[GESTURE] Failed to install GestureFilter on view: view is null";
    }
    
    window.show(); // epaper platform, show() triggers painting to fb0
    window.raise();
    window.activateWindow();
    QTimer::singleShot(800, [&window, &fbRef](){
        const int w = window.width();
        const int h = window.height();
        qInfo() << "[EINK] Startup: initial full refresh";
        fbRef.refreshFull(w, h);
    });
    int result = app.exec();
    return result;
}

#include "main.moc"
