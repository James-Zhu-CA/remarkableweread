#define _POSIX_C_SOURCE 200809L

#include <QGuiApplication>
#include <QQmlApplicationEngine>
#include <QQmlContext>
#include <QQmlEngine>
#include <QQuickImageProvider>
#include <QTimer>
#include <QImage>
#include <QDebug>
#include <QFile>
#include <QByteArray>
#include <QScopedPointer>
#include <QUdpSocket>
#include <QHostAddress>
#include <QMouseEvent>
#include <QTouchEvent>
#include <QCoreApplication>
#include <QScreen>
#include <QVector>
#include <QtMath>
#include <QElapsedTimer>
#include <QDateTime>
#include <QProcess>
#include <functional>
#include <optional>
#include <tuple>
#include <cstring>
#include <cstdlib>
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>

#include "../shm_proto.h"

static const char kViewerVersion[] = "2.0";
static const char kQtfbSocketPath[] = "/tmp/qtfb.sock";
static const uint32_t kQtfbDefaultKey = 245209899;
static const uint8_t kQtfbFormatRgb565 = 3; // FBFMT_RMPP_RGB565 from qtfb common.h

class ShmImageProvider : public QQuickImageProvider {
public:
    ShmImageProvider() : QQuickImageProvider(QQuickImageProvider::Image) {}
    void setBuffers(uint8_t *buf0, uint8_t *buf1, const ShmHeader *hdr) {
        m_buf0 = buf0; m_buf1 = buf1; m_hdr = hdr;
    }
    void setFormat(QImage::Format fmt) { m_format = fmt; }
    QImage requestImage(const QString &, QSize *size, const QSize &) override {
        if (!m_hdr || !m_buf0) return {};
        const uint8_t *src = (m_hdr->active_buffer == 0) ? m_buf0 : m_buf1;
        QImage img(src, static_cast<int>(m_hdr->width), static_cast<int>(m_hdr->height),
                   static_cast<int>(m_hdr->stride), m_format);
        if (size) *size = img.size();
        QImage copy = img.copy(); // detach from shm
        return copy;
    }
private:
    const ShmHeader *m_hdr = nullptr;
    uint8_t *m_buf0 = nullptr;
    uint8_t *m_buf1 = nullptr;
    QImage::Format m_format = QImage::Format_ARGB32;
};

struct QtfbMessage {
    uint8_t type;
    union {
        struct {
            uint32_t framebufferKey;
            uint8_t framebufferType;
        } init;
        struct {
            uint32_t framebufferKey;
            uint8_t framebufferType;
            uint16_t width;
            uint16_t height;
        } customInit;
        struct {
            int type;
            int x, y, w, h;
        } update;
    };
};

struct QtfbInitResp {
    uint8_t type;
    struct {
        int shmKeyDefined;
        size_t shmSize;
    } init;
};

class QtfbSink {
public:
    static std::unique_ptr<QtfbSink> create(const ShmHeader *hdr) {
        if (!hdr) return nullptr;
        uint32_t key = kQtfbDefaultKey;
        if (const char *env = std::getenv("QTFB_KEY")) {
            const uint32_t parsed = static_cast<uint32_t>(std::strtoul(env, nullptr, 10));
            if (parsed > 0) key = parsed;
        }
        const uint16_t w = static_cast<uint16_t>(hdr->width);
        const uint16_t h = static_cast<uint16_t>(hdr->height);
        auto sink = std::unique_ptr<QtfbSink>(new QtfbSink());
        if (!sink->init(key, w, h)) {
            return nullptr;
        }
        return sink;
    }

    ~QtfbSink() {
        if (m_shm && m_shmSize) {
            munmap(m_shm, m_shmSize);
        }
        if (m_sock >= 0) close(m_sock);
    }

    void pushFrame(const ShmHeader *hdr, const uint8_t *src) {
        if (!hdr || !src || !m_shm) return;
        // We always advertise RGB565 to qtfb; convert if needed.
        if (hdr->format == SHM_FMT_RGB565) {
            const size_t copyStride = std::min(static_cast<size_t>(hdr->stride), m_destStride);
            const size_t rows = std::min(static_cast<size_t>(hdr->height), static_cast<size_t>(m_height));
            for (size_t y = 0; y < rows; ++y) {
                const uint8_t *rowSrc = src + y * hdr->stride;
                uint8_t *rowDst = m_shm + y * m_destStride;
                std::memcpy(rowDst, rowSrc, copyStride);
            }
        } else if (hdr->format == SHM_FMT_ARGB32) {
            const size_t rows = std::min(static_cast<size_t>(hdr->height), static_cast<size_t>(m_height));
            for (size_t y = 0; y < rows; ++y) {
                const uint8_t *rowSrc = src + y * hdr->stride;
                uint16_t *rowDst = reinterpret_cast<uint16_t *>(m_shm + y * m_destStride);
                for (size_t x = 0; x < static_cast<size_t>(hdr->width) && x < m_width; ++x) {
                    const uint32_t pix = *(reinterpret_cast<const uint32_t *>(rowSrc + x * 4));
                    const uint8_t r = static_cast<uint8_t>((pix >> 16) & 0xFF);
                    const uint8_t g = static_cast<uint8_t>((pix >> 8) & 0xFF);
                    const uint8_t b = static_cast<uint8_t>(pix & 0xFF);
                    rowDst[x] = static_cast<uint16_t>(((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3));
                }
            }
        } else {
            qWarning() << "[QTFB] unsupported format" << hdr->format;
            return;
        }
        sendUpdate();
    }

private:
    QtfbSink() = default;

    bool init(uint32_t key, uint16_t width, uint16_t height) {
        m_sock = ::socket(AF_UNIX, SOCK_SEQPACKET, 0);
        if (m_sock < 0) {
            qWarning() << "[QTFB] socket failed" << strerror(errno);
            return false;
        }
        sockaddr_un addr{};
        addr.sun_family = AF_UNIX;
        std::strncpy(addr.sun_path, kQtfbSocketPath, sizeof(addr.sun_path) - 1);
        if (::connect(m_sock, reinterpret_cast<sockaddr *>(&addr), sizeof(addr)) != 0) {
            qWarning() << "[QTFB] connect failed" << strerror(errno);
            return false;
        }
        QtfbMessage initMsg{};
        initMsg.type = 2; // MESSAGE_CUSTOM_INITIALIZE
        initMsg.customInit.framebufferKey = key;
        initMsg.customInit.framebufferType = kQtfbFormatRgb565;
        initMsg.customInit.width = width;
        initMsg.customInit.height = height;
        if (::send(m_sock, &initMsg, sizeof(initMsg), 0) == -1) {
            qWarning() << "[QTFB] send init failed" << strerror(errno);
            return false;
        }
        QtfbInitResp resp{};
        if (::recv(m_sock, &resp, sizeof(resp), 0) < 1) {
            qWarning() << "[QTFB] recv init failed" << strerror(errno);
            return false;
        }
        char shmName[20];
        std::snprintf(shmName, sizeof(shmName), "/qtfb_%d", resp.init.shmKeyDefined);
        const int shmFd = ::shm_open(shmName, O_RDWR, 0);
        if (shmFd == -1) {
            qWarning() << "[QTFB] shm_open failed" << strerror(errno);
            return false;
        }
        void *mem = ::mmap(nullptr, resp.init.shmSize, PROT_READ | PROT_WRITE, MAP_SHARED, shmFd, 0);
        ::close(shmFd);
        if (mem == MAP_FAILED) {
            qWarning() << "[QTFB] mmap failed" << strerror(errno);
            return false;
        }
        m_shm = static_cast<uint8_t *>(mem);
        m_shmSize = resp.init.shmSize;
        m_width = width;
        m_height = height;
        m_destStride = static_cast<size_t>(width) * 2; // RGB565
        qInfo() << "[QTFB] connected key" << key << "w" << m_width << "h" << m_height << "shm" << m_shmSize;
        return true;
    }

    void sendUpdate() {
        if (m_sock < 0) return;
        QtfbMessage update{};
        update.type = 1; // MESSAGE_UPDATE
        update.update.type = 0; // UPDATE_ALL
        update.update.x = 0;
        update.update.y = 0;
        update.update.w = static_cast<int>(m_width);
        update.update.h = static_cast<int>(m_height);
        ::send(m_sock, &update, sizeof(update), 0);
    }

    int m_sock = -1;
    uint8_t *m_shm = nullptr;
    size_t m_shmSize = 0;
    size_t m_destStride = 0;
    uint16_t m_width = 0;
    uint16_t m_height = 0;
};

class ShmWatcher : public QObject {
    Q_OBJECT
    Q_PROPERTY(uint gen READ gen NOTIFY genChanged)
public:
    explicit ShmWatcher(QObject *parent = nullptr) : QObject(parent) {
        m_timer.setInterval(200);
        connect(&m_timer, &QTimer::timeout, this, &ShmWatcher::poll);
    }
    uint gen() const { return m_gen; }
    bool init(const QString &path, ShmImageProvider *provider) {
        int fd = ::open(path.toUtf8().constData(), O_RDONLY);
        if (fd < 0) {
            qWarning() << "open failed" << strerror(errno);
            return false;
        }
        struct stat st{};
        if (::fstat(fd, &st) != 0) {
            qWarning() << "fstat failed";
            ::close(fd);
            return false;
        }
        void *base = mmap(nullptr, st.st_size, PROT_READ, MAP_SHARED, fd, 0);
        ::close(fd);
        if (base == MAP_FAILED) {
            qWarning() << "mmap failed" << strerror(errno);
            return false;
        }
        m_base.reset(base, st.st_size);
        m_hdr = reinterpret_cast<const ShmHeader *>(base);
        if (m_hdr->magic != SHM_MAGIC || m_hdr->version != SHM_VERSION) {
            qWarning() << "bad magic/version";
            return false;
        }
        qInfo() << "[SHM] init ok"
                << "w" << m_hdr->width << "h" << m_hdr->height
                << "stride" << m_hdr->stride
                << "format" << m_hdr->format
                << "gen" << m_hdr->gen_counter;
        const size_t headerBytes = sizeof(ShmHeader);
        m_buf0 = reinterpret_cast<uint8_t *>(base) + headerBytes;
        m_buf1 = m_buf0 + static_cast<size_t>(m_hdr->stride) * m_hdr->height;
        provider->setBuffers(m_buf0, m_buf1, m_hdr);
        QImage::Format fmt = QImage::Format_ARGB32;
        if (m_hdr->format == SHM_FMT_RGB565) fmt = QImage::Format_RGB16;
        provider->setFormat(fmt);
        m_gen = m_hdr->gen_counter;
        emit genChanged();
        m_timer.start();
        return true;
    }
signals:
    void genChanged();
    void frameReady();
private slots:
    void poll() {
        if (!m_hdr) return;
        if (m_hdr->gen_counter != m_gen) {
            m_gen = m_hdr->gen_counter;
            emit frameReady();
            emit genChanged();
        }
    }
private:
    struct MmapDeleter {
        void operator()(void *p, size_t sz) const {
            if (p) munmap(p, sz);
        }
    };
    struct MmapPtr {
        MmapPtr() : ptr(nullptr), sz(0) {}
        MmapPtr(void *p, size_t s) : ptr(p), sz(s) {}
        void reset(void *p, size_t s) { ptr = p; sz = s; }
        ~MmapPtr() { if (ptr) munmap(ptr, sz); }
        void *ptr; size_t sz;
    };
    MmapPtr m_base;
    const ShmHeader *m_hdr = nullptr;
    uint8_t *m_buf0 = nullptr;
    uint8_t *m_buf1 = nullptr;
    uint m_gen = 0;
    QTimer m_timer;

public:
    const ShmHeader *hdr() const { return m_hdr; }
    const uint8_t *activeBuffer() const {
        if (!m_hdr) return nullptr;
        return (m_hdr->active_buffer == 0) ? m_buf0 : m_buf1;
    }
};

class TouchSender : public QObject {
    Q_OBJECT
public:
    explicit TouchSender(QObject *parent = nullptr) : QObject(parent) {
        target = QHostAddress(QStringLiteral("127.0.0.1"));
        socket.connectToHost(target, 45454);
        if (auto screen = QGuiApplication::primaryScreen()) {
            const QSize s = screen->size();
            windowHeight = s.height();
            windowWidth = s.width();
        }
        // listen for book/non-book state updates on UDP 45456 (1 byte: 1=book,0=non-book)
        if (stateSocket.bind(QHostAddress::LocalHost, 45456,
                             QUdpSocket::ShareAddress | QUdpSocket::ReuseAddressHint)) {
            qInfo() << "[GESTURE] state socket bound, default isBookPage" << isBookPage;
            connect(&stateSocket, &QUdpSocket::readyRead, this, [this]() {
                while (stateSocket.hasPendingDatagrams()) {
                    QByteArray d;
                    d.resize(int(stateSocket.pendingDatagramSize()));
                    stateSocket.readDatagram(d.data(), d.size());
                    if (!d.isEmpty()) {
                        bool newState = d.at(0) != 0;
                        if (newState != isBookPage) {
                            isBookPage = newState;
                            qInfo() << "[GESTURE] isBookPage set to" << isBookPage;
                        }
                        hasState = true;
                        stateTimer.stop();
                    }
                }
            });
        } else {
            qWarning() << "[GESTURE] failed to bind state socket";
        }
        // periodic request until we have a state
        stateTimer.setSingleShot(false);
        stateTimer.setInterval(2000);
        connect(&stateTimer, &QTimer::timeout, this, [this]() {
            if (hasState) { stateTimer.stop(); return; }
            QByteArray req(1, '\xFF'); // arbitrary content to signal request
            const qint64 sent = stateRequestSocket.writeDatagram(req, target, 45457);
            qInfo() << "[GESTURE] requesting isBookPage state bytes" << sent;
        });
        stateTimer.start();
        // fire an immediate request so we don't wait for the first interval
        QMetaObject::invokeMethod(this, [this]() {
            if (!hasState) {
                QByteArray req(1, '\xFF');
                const qint64 sent = stateRequestSocket.writeDatagram(req, target, 45457);
                qInfo() << "[GESTURE] requesting isBookPage state bytes" << sent;
            }
        }, Qt::QueuedConnection);
        // menu timeout
        menuTimer.setSingleShot(true);
        menuTimer.setInterval(5000);
        connect(&menuTimer, &QTimer::timeout, this, [this]() {
            menuActive = false;
            menuTap = false;
            qInfo() << "[MENU] timed out ts" << QDateTime::currentMSecsSinceEpoch();
        });
    }

    void setWindowHeight(qreal h) { windowHeight = h; }
    void setWindowWidth(qreal w) { windowWidth = w; }
    bool eventFilter(QObject *obj, QEvent *event) override {
        switch (event->type()) {
        case QEvent::MouseButtonPress:
        case QEvent::MouseButtonRelease:
        case QEvent::MouseMove: {
            auto *me = static_cast<QMouseEvent *>(event);
            handlePoint(me->position(), event->type());
            return true; // always handle here
        }
        case QEvent::TouchBegin:
        case QEvent::TouchUpdate:
        case QEvent::TouchEnd: {
            auto *te = static_cast<QTouchEvent *>(event);
            const auto points = te->points();
            if (!points.isEmpty()) {
                handlePoint(points.first().position(), event->type());
            }
            return true;
        }
        default:
            break;
        }
        return QObject::eventFilter(obj, event);
    }

signals:
    void exitGestureDetected();

private:
    enum SpecialType : quint8 {
        EXIT = 101,
        BACK = 102,
        NEXT_PAGE = 103,
        PREV_PAGE = 104,
        SCROLL_UP = 105,
        SCROLL_DOWN = 106,
        MENU_OPEN = 107,
        MENU_FONT_TOGGLE = 108,
        MENU_FONT_UP = 109,
        MENU_FONT_DOWN = 110,
        MENU_UA = 111,      // 以前的 MENU_THEME，现用于 UA 切换
        MENU_SERVICE = 112
    };

    struct Payload { quint8 type; quint8 pad[3]; float x; float y; };

    void sendPayload(const Payload &p) {
        socket.writeDatagram(reinterpret_cast<const char*>(&p), sizeof(p), target, 45454);
        const qint64 ts = QDateTime::currentMSecsSinceEpoch();
        qInfo() << "[TOUCH-SEND]" << "ts" << ts << "type" << p.type << "pos" << p.x << p.y;
    }

    void sendCommand(SpecialType t) {
        Payload p{}; p.type = static_cast<quint8>(t); p.x = 0; p.y = 0; sendPayload(p);
    }

    void logAction(const char* action, const QPointF& pos, qreal dx, qreal dy) {
        const qint64 ts = QDateTime::currentMSecsSinceEpoch();
        qInfo() << "[GESTURE]" << action
                << "ts" << ts
                << "start" << startPos << "end" << pos
                << "dx" << dx << "dy" << dy
                << "isBookPage" << isBookPage
                << "startInBottom" << candidateExit;
    }

    void flushBuffered() {
        for (const auto &p : buffered) sendPayload(p);
        buffered.clear();
    }

    void handlePoint(const QPointF &pos, QEvent::Type type) {
        Payload p{};
        p.type = (type == QEvent::MouseButtonPress || type == QEvent::TouchBegin) ? 1 :
                 (type == QEvent::MouseButtonRelease || type == QEvent::TouchEnd) ? 3 : 2;
        p.x = pos.x();
        p.y = pos.y();

        // 额外的原始触摸日志，方便排查触摸是否送达 viewer
        qInfo() << "[TOUCH-RAW]" << "ts" << QDateTime::currentMSecsSinceEpoch()
                << ((p.type==1)?"press":(p.type==3)?"release":"move")
                << "pos" << pos << "type" << p.type << "isBook" << isBookPage;

        if (p.type == 1) {
            inGesture = true;
            candidateExit = (pos.y() >= windowHeight - bottomMargin);
            swallowThisGesture = false;
            buffered.clear();
            startPos = pos;
            elapsed.restart();
            buffered.push_back(p); // always buffer; decide on release
            // If menu active, intercept top taps for menu actions
            if (menuActive && pos.y() <= menuTopHeight) {
                menuTap = true;
                swallowThisGesture = true;
                return;
            }
            return;
        }

        if (!inGesture) { return; }

        // Exit / Back detection
        if (!swallowThisGesture) {
            buffered.push_back(p);
            qreal dy = startPos.y() - pos.y();
            qreal dx = pos.x() - startPos.x();
            qreal absDx = qAbs(dx);
            qreal absDy = qAbs(dy);
            if (candidateExit && dy >= exitDelta && absDx <= exitHorizTol) {
                logAction("EXIT", pos, dx, -dy);
                swallowThisGesture = true; buffered.clear(); emit exitGestureDetected();
            } else if (!candidateExit && startPos.x() <= leftEdge && dx >= backDelta && absDy <= backVertTol) {
                logAction("BACK", pos, dx, -dy);
                swallowThisGesture = true; buffered.clear(); sendCommand(BACK);
            } else if (startPos.y() <= topMargin && -dy >= menuDelta && absDx <= topHorizTol) {
                logAction("MENU_OPEN", pos, dx, -dy);
                swallowThisGesture = true; buffered.clear(); sendCommand(MENU_OPEN);
                menuActive = true;
                menuTap = false;
                menuTimer.start();
            } else if (startPos.y() <= topMargin) {
                logAction("MENU_CANDIDATE_NO_TRIGGER", pos, dx, -dy);
            }
        }

        // Page / scroll gestures
        if (!swallowThisGesture) {
            qreal dy = pos.y() - startPos.y();
            qreal dx = pos.x() - startPos.x();
            qreal absDy = qAbs(dy);
            bool inMiddle = (startPos.x() >= leftEdge && startPos.x() <= windowWidth - rightEdge);
            if (isBookPage && inMiddle) {
                const bool startValid = startPos.y() > 60.0;
                if (startValid && dx <= -pageSwipeMin && absDy <= pageVertTol) { logAction("NEXT_PAGE", pos, dx, dy); swallowThisGesture = true; buffered.clear(); sendCommand(NEXT_PAGE); }
                else if (startValid && dx >= pageSwipeMin && absDy <= pageVertTol) { logAction("PREV_PAGE", pos, dx, dy); swallowThisGesture = true; buffered.clear(); sendCommand(PREV_PAGE); }
            } else if (!isBookPage && inMiddle) {
                // swapped: drag up -> scroll down; drag down -> scroll up (1 page step handled frontend)
                if (dy <= -scrollMin) { logAction("SCROLL_DOWN", pos, dx, dy); swallowThisGesture = true; buffered.clear(); sendCommand(SCROLL_DOWN); }
                else if (dy >= scrollMin) { logAction("SCROLL_UP", pos, dx, dy); swallowThisGesture = true; buffered.clear(); sendCommand(SCROLL_UP); }
            }
        }

        if (menuActive && menuTap && p.type == 3) {
            // menu tap release: map x to action
            const qreal colWidth = windowWidth / 5.0;
            int idx = static_cast<int>(pos.x() / colWidth);
            if (idx < 0) idx = 0;
            if (idx > 4) idx = 4;
            switch (idx) {
            case 0: sendCommand(MENU_FONT_TOGGLE); logAction("MENU_FONT_TOGGLE", pos, 0, 0); break;
            case 1: sendCommand(MENU_SERVICE); logAction("MENU_SERVICE", pos, 0, 0); break;
            case 2: sendCommand(MENU_FONT_UP); logAction("MENU_FONT_UP", pos, 0, 0); break;
            case 3: sendCommand(MENU_FONT_DOWN); logAction("MENU_FONT_DOWN", pos, 0, 0); break;
            case 4: sendCommand(MENU_UA); logAction("MENU_UA", pos, 0, 0); break;
            }
            menuTap = false;
            menuTimer.start();
            inGesture = false;
            candidateExit = false;
            swallowThisGesture = false;
            buffered.clear();
            return;
        }

        if (p.type == 3) {
            if (!swallowThisGesture) {
                qreal dx = pos.x() - startPos.x();
                qreal dy = pos.y() - startPos.y();
                qreal absDx = qAbs(dx);
                qreal absDy = qAbs(dy);
                qint64 ms = elapsed.elapsed();
            if (menuActive && !menuTap) {
                // ignore clicks during menu mode outside the top area
                logAction("MENU_ACTIVE_SWALLOW", pos, dx, dy);
                menuActive = false;
                menuTap = false;
                menuTimer.stop();
                    inGesture = false;
                    candidateExit = false;
                    swallowThisGesture = false;
                    buffered.clear();
                    return;
                }
                bool isTap = (ms < tapMs && absDx < tapThreshold && absDy < tapThreshold);
                bool isLong = (ms >= tapMs && absDx < tapThreshold && absDy < tapThreshold);
                if (isBookPage) {
                    if (isTap) {
                        logAction("TAP_NEXT_PAGE", pos, dx, dy);
                        sendCommand(NEXT_PAGE);
                    } else if (isLong) {
                        logAction("LONG_PRESS_PASS", pos, dx, dy);
                        flushBuffered(); // long press passes through
                    } else {
                        qInfo() << "[GESTURE] discard book gesture"
                                << "start" << startPos << "end" << pos
                                << "tap=false long=false"
                                << "absDx" << absDx << "absDy" << absDy << "ms" << ms
                                << "isBookPage" << isBookPage
                                << "startInBottom" << candidateExit;
                    }
                } else { // non-book
                    if (isTap || isLong) {
                        logAction(isTap ? "TAP_PASS" : "LONG_PRESS_PASS", pos, dx, dy);
                        flushBuffered(); // allow click/long-press
                    } else {
                        qInfo() << "[GESTURE] discard non-book gesture"
                                << "start" << startPos << "end" << pos
                                << "tap=false long=false"
                                << "absDx" << absDx << "absDy" << absDy << "ms" << ms
                                << "isBookPage" << isBookPage
                                << "startInBottom" << candidateExit;
                    }
                }
            }
            inGesture = false;
            candidateExit = false;
            swallowThisGesture = false;
            buffered.clear();
        }
    }

    QUdpSocket socket;
    QHostAddress target;
    QUdpSocket stateSocket;
    bool inGesture = false;
    bool candidateExit = false;
    bool swallowThisGesture = false;
    bool menuActive = false;
    bool menuTap = false;
    QPointF startPos;
    QVector<Payload> buffered;
    qreal windowHeight = 1696.0;
    qreal windowWidth = 1404.0;
    QElapsedTimer elapsed;
    bool isBookPage = false; // updated via UDP 45456
    bool hasState = false;

    // thresholds
    const qreal bottomMargin = 100.0;
    const qreal exitDelta = 100.0;
    const qreal exitHorizTol = 200.0;
    const qreal leftEdge = 40.0;
    const qreal rightEdge = 40.0;
    const qreal topMargin = 80.0;
    const qreal backDelta = 200.0;
    const qreal backVertTol = 250.0;
    const qreal topHorizTol = 150.0;
    const qreal menuDelta = 100.0;
    const qreal menuTopHeight = 120.0;
    const qreal pageSwipeMin = 100.0;
    const qreal pageVertTol = 250.0;
    const qreal scrollMin = 100.0;
    const qreal tapThreshold = 100.0;
    const qint64 tapMs = 500;
    QUdpSocket stateRequestSocket;
    QTimer stateTimer;
    QTimer menuTimer;
};

class ExitHelper : public QObject {
    Q_OBJECT
public:
    explicit ExitHelper(QObject *parent = nullptr) : QObject(parent) {}
    Q_INVOKABLE void exitToXochitl() {
        QProcess::startDetached(QStringLiteral("/home/root/weread/exit-wechatread.sh"));
    }
};

int main(int argc, char *argv[]) {
    QCoreApplication::setApplicationVersion(QString::fromLatin1(kViewerVersion));
    const bool enableQtfb = std::getenv("QTFB_ENABLE") == nullptr || std::strcmp(std::getenv("QTFB_ENABLE"), "0") != 0;

    QCoreApplication::setAttribute(Qt::AA_SynthesizeMouseForUnhandledTouchEvents);
    QCoreApplication::setAttribute(Qt::AA_SynthesizeTouchForUnhandledMouseEvents);

    QGuiApplication app(argc, argv);
    qInfo() << "[VIEWER] version" << QCoreApplication::applicationVersion()
            << (enableQtfb ? "[QTFB MODE]" : "[DIRECT MODE]");

    auto provider = new ShmImageProvider();
    ShmWatcher watcher;
    if (!watcher.init("/dev/shm/weread_frame", provider)) {
        qWarning() << "Failed to init shm watcher";
    }

    std::unique_ptr<QtfbSink> qtfbSink;
    if (enableQtfb && watcher.hdr()) {
        qtfbSink = QtfbSink::create(watcher.hdr());
        if (!qtfbSink) {
            qWarning() << "[QTFB] init failed, falling back to direct mode";
        } else {
            qtfbSink->pushFrame(watcher.hdr(), watcher.activeBuffer());
        }
    }

    if (qtfbSink) {
        QObject::connect(&watcher, &ShmWatcher::frameReady, [&watcher, &qtfbSink]() {
            if (qtfbSink) {
                qtfbSink->pushFrame(watcher.hdr(), watcher.activeBuffer());
            }
        });
    }

    // If qtfb is enabled and initialized, we can run headless (no QML window).
    if (qtfbSink) {
        return app.exec();
    }

    QQmlApplicationEngine engine;
    engine.addImageProvider("shmframe", provider);
    engine.rootContext()->setContextProperty("shmWatcher", &watcher);

    TouchSender sender;
    app.installEventFilter(&sender);

    ExitHelper exitHelper;
    engine.rootContext()->setContextProperty("exitHelper", &exitHelper);
    QObject::connect(&sender, &TouchSender::exitGestureDetected,
                     &exitHelper, &ExitHelper::exitToXochitl);

    using namespace Qt::StringLiterals;
    const QString qmlPath = QCoreApplication::applicationDirPath() + "/main.qml";
    const QUrl url = QUrl::fromLocalFile(qmlPath);
    QObject::connect(&engine, &QQmlApplicationEngine::objectCreated,
                     &app, [url](QObject *obj, const QUrl &objUrl) {
        if (!obj && url == objUrl) QCoreApplication::exit(-1);
    }, Qt::QueuedConnection);
    engine.load(url);
    return app.exec();
}

#include "main.moc"
