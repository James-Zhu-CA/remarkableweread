#define _POSIX_C_SOURCE 200809L

#include <QGuiApplication>
#include <QQmlApplicationEngine>
#include <QQmlContext>
#include <QQmlEngine>
#include <QQuickImageProvider>
#include <QTimer>
#include <QImage>
#include <QDebug>
#include <QFile>
#include <QByteArray>
#include <QScopedPointer>
#include <QUdpSocket>
#include <QHostAddress>
#include <QMouseEvent>
#include <QTouchEvent>
#include <QCoreApplication>
#include <QScreen>
#include <QVector>
#include <QtMath>
#include <QElapsedTimer>
#include <QDateTime>
#include <QProcess>
#include <functional>
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>

#include "../shm_proto.h"

static const char kViewerVersion[] = "1.0";

class ShmImageProvider : public QQuickImageProvider {
public:
    ShmImageProvider() : QQuickImageProvider(QQuickImageProvider::Image) {}
    void setBuffers(uint8_t *buf0, uint8_t *buf1, const ShmHeader *hdr) {
        m_buf0 = buf0; m_buf1 = buf1; m_hdr = hdr;
    }
    void setFormat(QImage::Format fmt) { m_format = fmt; }
    QImage requestImage(const QString &, QSize *size, const QSize &) override {
        if (!m_hdr || !m_buf0) return {};
        const uint8_t *src = (m_hdr->active_buffer == 0) ? m_buf0 : m_buf1;
        QImage img(src, static_cast<int>(m_hdr->width), static_cast<int>(m_hdr->height),
                   static_cast<int>(m_hdr->stride), m_format);
        if (size) *size = img.size();
        QImage copy = img.copy(); // detach from shm
        return copy;
    }
private:
    const ShmHeader *m_hdr = nullptr;
    uint8_t *m_buf0 = nullptr;
    uint8_t *m_buf1 = nullptr;
    QImage::Format m_format = QImage::Format_ARGB32;
};

class ShmWatcher : public QObject {
    Q_OBJECT
    Q_PROPERTY(uint gen READ gen NOTIFY genChanged)
public:
    explicit ShmWatcher(QObject *parent = nullptr) : QObject(parent) {
        m_timer.setInterval(200);
        connect(&m_timer, &QTimer::timeout, this, &ShmWatcher::poll);
    }
    uint gen() const { return m_gen; }
    bool init(const QString &path, ShmImageProvider *provider) {
        int fd = ::open(path.toUtf8().constData(), O_RDONLY);
        if (fd < 0) {
            qWarning() << "open failed" << strerror(errno);
            return false;
        }
        struct stat st{};
        if (::fstat(fd, &st) != 0) {
            qWarning() << "fstat failed";
            ::close(fd);
            return false;
        }
        void *base = mmap(nullptr, st.st_size, PROT_READ, MAP_SHARED, fd, 0);
        ::close(fd);
        if (base == MAP_FAILED) {
            qWarning() << "mmap failed" << strerror(errno);
            return false;
        }
        m_base.reset(base, st.st_size);
        m_hdr = reinterpret_cast<const ShmHeader *>(base);
        if (m_hdr->magic != SHM_MAGIC || m_hdr->version != SHM_VERSION) {
            qWarning() << "bad magic/version";
            return false;
        }
        qInfo() << "[SHM] init ok"
                << "w" << m_hdr->width << "h" << m_hdr->height
                << "stride" << m_hdr->stride
                << "format" << m_hdr->format
                << "gen" << m_hdr->gen_counter;
        const size_t headerBytes = sizeof(ShmHeader);
        uint8_t *buf0 = reinterpret_cast<uint8_t *>(base) + headerBytes;
        uint8_t *buf1 = buf0 + static_cast<size_t>(m_hdr->stride) * m_hdr->height;
        provider->setBuffers(buf0, buf1, m_hdr);
        QImage::Format fmt = QImage::Format_ARGB32;
        if (m_hdr->format == SHM_FMT_RGB565) fmt = QImage::Format_RGB16;
        provider->setFormat(fmt);
        m_gen = m_hdr->gen_counter;
        emit genChanged();
        m_timer.start();
        return true;
    }
signals:
    void genChanged();
private slots:
    void poll() {
        if (!m_hdr) return;
        if (m_hdr->gen_counter != m_gen) {
            m_gen = m_hdr->gen_counter;
            emit genChanged();
        }
    }
private:
    struct MmapDeleter {
        void operator()(void *p, size_t sz) const {
            if (p) munmap(p, sz);
        }
    };
    struct MmapPtr {
        MmapPtr() : ptr(nullptr), sz(0) {}
        MmapPtr(void *p, size_t s) : ptr(p), sz(s) {}
        void reset(void *p, size_t s) { ptr = p; sz = s; }
        ~MmapPtr() { if (ptr) munmap(ptr, sz); }
        void *ptr; size_t sz;
    };
    MmapPtr m_base;
    const ShmHeader *m_hdr = nullptr;
    uint m_gen = 0;
    QTimer m_timer;
};

class TouchSender : public QObject {
    Q_OBJECT
public:
    explicit TouchSender(QObject *parent = nullptr) : QObject(parent) {
        target = QHostAddress(QStringLiteral("127.0.0.1"));
        socket.connectToHost(target, 45454);
        if (auto screen = QGuiApplication::primaryScreen()) {
            const QSize s = screen->size();
            windowHeight = s.height();
            windowWidth = s.width();
        }
        // listen for book/non-book state updates on UDP 45456 (1 byte: 1=book,0=non-book)
        if (stateSocket.bind(QHostAddress::LocalHost, 45456,
                             QUdpSocket::ShareAddress | QUdpSocket::ReuseAddressHint)) {
            qInfo() << "[GESTURE] state socket bound, default isBookPage" << isBookPage;
            connect(&stateSocket, &QUdpSocket::readyRead, this, [this]() {
                while (stateSocket.hasPendingDatagrams()) {
                    QByteArray d;
                    d.resize(int(stateSocket.pendingDatagramSize()));
                    stateSocket.readDatagram(d.data(), d.size());
                    if (!d.isEmpty()) {
                        bool newState = d.at(0) != 0;
                        if (newState != isBookPage) {
                            isBookPage = newState;
                            qInfo() << "[GESTURE] isBookPage set to" << isBookPage;
                        }
                        hasState = true;
                        stateTimer.stop();
                    }
                }
            });
        } else {
            qWarning() << "[GESTURE] failed to bind state socket";
        }
        // periodic request until we have a state
        stateTimer.setSingleShot(false);
        stateTimer.setInterval(2000);
        connect(&stateTimer, &QTimer::timeout, this, [this]() {
            if (hasState) { stateTimer.stop(); return; }
            QByteArray req(1, '\xFF'); // arbitrary content to signal request
            const qint64 sent = stateRequestSocket.writeDatagram(req, target, 45457);
            qInfo() << "[GESTURE] requesting isBookPage state bytes" << sent;
        });
        stateTimer.start();
        // fire an immediate request so we don't wait for the first interval
        QMetaObject::invokeMethod(this, [this]() {
            if (!hasState) {
                QByteArray req(1, '\xFF');
                const qint64 sent = stateRequestSocket.writeDatagram(req, target, 45457);
                qInfo() << "[GESTURE] requesting isBookPage state bytes" << sent;
            }
        }, Qt::QueuedConnection);
        // menu timeout
        menuTimer.setSingleShot(true);
        menuTimer.setInterval(5000);
        connect(&menuTimer, &QTimer::timeout, this, [this]() {
            menuActive = false;
            menuTap = false;
            qInfo() << "[MENU] timed out ts" << QDateTime::currentMSecsSinceEpoch();
        });
    }

    void setWindowHeight(qreal h) { windowHeight = h; }
    void setWindowWidth(qreal w) { windowWidth = w; }
    bool eventFilter(QObject *obj, QEvent *event) override {
        switch (event->type()) {
        case QEvent::MouseButtonPress:
        case QEvent::MouseButtonRelease:
        case QEvent::MouseMove: {
            auto *me = static_cast<QMouseEvent *>(event);
            handlePoint(me->position(), event->type());
            return true; // always handle here
        }
        case QEvent::TouchBegin:
        case QEvent::TouchUpdate:
        case QEvent::TouchEnd: {
            auto *te = static_cast<QTouchEvent *>(event);
            const auto points = te->points();
            if (!points.isEmpty()) {
                handlePoint(points.first().position(), event->type());
            }
            return true;
        }
        default:
            break;
        }
        return QObject::eventFilter(obj, event);
    }

signals:
    void exitGestureDetected();

private:
    enum SpecialType : quint8 {
        EXIT = 101,
        BACK = 102,
        NEXT_PAGE = 103,
        PREV_PAGE = 104,
        SCROLL_UP = 105,
        SCROLL_DOWN = 106,
        MENU_OPEN = 107,
        MENU_FONT_TOGGLE = 108,
        MENU_FONT_UP = 109,
        MENU_FONT_DOWN = 110,
        MENU_UA = 111,      // 以前的 MENU_THEME，现用于 UA 切换
        MENU_SERVICE = 112
    };

    struct Payload { quint8 type; quint8 pad[3]; float x; float y; };

    void sendPayload(const Payload &p) {
        socket.writeDatagram(reinterpret_cast<const char*>(&p), sizeof(p), target, 45454);
        const qint64 ts = QDateTime::currentMSecsSinceEpoch();
        qInfo() << "[TOUCH-SEND]" << "ts" << ts << "type" << p.type << "pos" << p.x << p.y;
    }

    void sendCommand(SpecialType t) {
        Payload p{}; p.type = static_cast<quint8>(t); p.x = 0; p.y = 0; sendPayload(p);
    }

    void logAction(const char* action, const QPointF& pos, qreal dx, qreal dy) {
        const qint64 ts = QDateTime::currentMSecsSinceEpoch();
        qInfo() << "[GESTURE]" << action
                << "ts" << ts
                << "start" << startPos << "end" << pos
                << "dx" << dx << "dy" << dy
                << "isBookPage" << isBookPage
                << "startInBottom" << candidateExit;
    }

    void flushBuffered() {
        for (const auto &p : buffered) sendPayload(p);
        buffered.clear();
    }

    void handlePoint(const QPointF &pos, QEvent::Type type) {
        Payload p{};
        p.type = (type == QEvent::MouseButtonPress || type == QEvent::TouchBegin) ? 1 :
                 (type == QEvent::MouseButtonRelease || type == QEvent::TouchEnd) ? 3 : 2;
        p.x = pos.x();
        p.y = pos.y();

        // 额外的原始触摸日志，方便排查触摸是否送达 viewer
        qInfo() << "[TOUCH-RAW]" << "ts" << QDateTime::currentMSecsSinceEpoch()
                << ((p.type==1)?"press":(p.type==3)?"release":"move")
                << "pos" << pos << "type" << p.type << "isBook" << isBookPage;

        if (p.type == 1) {
            inGesture = true;
            candidateExit = (pos.y() >= windowHeight - bottomMargin);
            swallowThisGesture = false;
            buffered.clear();
            startPos = pos;
            elapsed.restart();
            buffered.push_back(p); // always buffer; decide on release
            // If menu active, intercept top taps for menu actions
            if (menuActive && pos.y() <= menuTopHeight) {
                menuTap = true;
                swallowThisGesture = true;
                return;
            }
            return;
        }

        if (!inGesture) { return; }

        // Exit / Back detection
        if (!swallowThisGesture) {
            buffered.push_back(p);
            qreal dy = startPos.y() - pos.y();
            qreal dx = pos.x() - startPos.x();
            qreal absDx = qAbs(dx);
            qreal absDy = qAbs(dy);
            if (candidateExit && dy >= exitDelta && absDx <= exitHorizTol) {
                logAction("EXIT", pos, dx, -dy);
                swallowThisGesture = true; buffered.clear(); emit exitGestureDetected();
            } else if (!candidateExit && startPos.x() <= leftEdge && dx >= backDelta && absDy <= backVertTol) {
                logAction("BACK", pos, dx, -dy);
                swallowThisGesture = true; buffered.clear(); sendCommand(BACK);
            } else if (startPos.y() <= topMargin && -dy >= menuDelta && absDx <= topHorizTol) {
                logAction("MENU_OPEN", pos, dx, -dy);
                swallowThisGesture = true; buffered.clear(); sendCommand(MENU_OPEN);
                menuActive = true;
                menuTap = false;
                menuTimer.start();
            } else if (startPos.y() <= topMargin) {
                logAction("MENU_CANDIDATE_NO_TRIGGER", pos, dx, -dy);
            }
        }

        // Page / scroll gestures
        if (!swallowThisGesture) {
            qreal dy = pos.y() - startPos.y();
            qreal dx = pos.x() - startPos.x();
            qreal absDy = qAbs(dy);
            bool inMiddle = (startPos.x() >= leftEdge && startPos.x() <= windowWidth - rightEdge);
            if (isBookPage && inMiddle) {
                const bool startValid = startPos.y() > 60.0;
                if (startValid && dx <= -pageSwipeMin && absDy <= pageVertTol) { logAction("NEXT_PAGE", pos, dx, dy); swallowThisGesture = true; buffered.clear(); sendCommand(NEXT_PAGE); }
                else if (startValid && dx >= pageSwipeMin && absDy <= pageVertTol) { logAction("PREV_PAGE", pos, dx, dy); swallowThisGesture = true; buffered.clear(); sendCommand(PREV_PAGE); }
            } else if (!isBookPage && inMiddle) {
                // swapped: drag up -> scroll down; drag down -> scroll up (1 page step handled frontend)
                if (dy <= -scrollMin) { logAction("SCROLL_DOWN", pos, dx, dy); swallowThisGesture = true; buffered.clear(); sendCommand(SCROLL_DOWN); }
                else if (dy >= scrollMin) { logAction("SCROLL_UP", pos, dx, dy); swallowThisGesture = true; buffered.clear(); sendCommand(SCROLL_UP); }
            }
        }

        if (menuActive && menuTap && p.type == 3) {
            // menu tap release: map x to action
            const qreal colWidth = windowWidth / 5.0;
            int idx = static_cast<int>(pos.x() / colWidth);
            if (idx < 0) idx = 0;
            if (idx > 4) idx = 4;
            switch (idx) {
            case 0: sendCommand(MENU_FONT_TOGGLE); logAction("MENU_FONT_TOGGLE", pos, 0, 0); break;
            case 1: sendCommand(MENU_SERVICE); logAction("MENU_SERVICE", pos, 0, 0); break;
            case 2: sendCommand(MENU_FONT_UP); logAction("MENU_FONT_UP", pos, 0, 0); break;
            case 3: sendCommand(MENU_FONT_DOWN); logAction("MENU_FONT_DOWN", pos, 0, 0); break;
            case 4: sendCommand(MENU_UA); logAction("MENU_UA", pos, 0, 0); break;
            }
            menuTap = false;
            menuTimer.start();
            inGesture = false;
            candidateExit = false;
            swallowThisGesture = false;
            buffered.clear();
            return;
        }

        if (p.type == 3) {
            if (!swallowThisGesture) {
                qreal dx = pos.x() - startPos.x();
                qreal dy = pos.y() - startPos.y();
                qreal absDx = qAbs(dx);
                qreal absDy = qAbs(dy);
                qint64 ms = elapsed.elapsed();
            if (menuActive && !menuTap) {
                // ignore clicks during menu mode outside the top area
                logAction("MENU_ACTIVE_SWALLOW", pos, dx, dy);
                menuActive = false;
                menuTap = false;
                menuTimer.stop();
                    inGesture = false;
                    candidateExit = false;
                    swallowThisGesture = false;
                    buffered.clear();
                    return;
                }
                bool isTap = (ms < tapMs && absDx < tapThreshold && absDy < tapThreshold);
                bool isLong = (ms >= tapMs && absDx < tapThreshold && absDy < tapThreshold);
                if (isBookPage) {
                    if (isTap) {
                        logAction("TAP_NEXT_PAGE", pos, dx, dy);
                        sendCommand(NEXT_PAGE);
                    } else if (isLong) {
                        logAction("LONG_PRESS_PASS", pos, dx, dy);
                        flushBuffered(); // long press passes through
                    } else {
                        qInfo() << "[GESTURE] discard book gesture"
                                << "start" << startPos << "end" << pos
                                << "tap=false long=false"
                                << "absDx" << absDx << "absDy" << absDy << "ms" << ms
                                << "isBookPage" << isBookPage
                                << "startInBottom" << candidateExit;
                    }
                } else { // non-book
                    if (isTap || isLong) {
                        logAction(isTap ? "TAP_PASS" : "LONG_PRESS_PASS", pos, dx, dy);
                        flushBuffered(); // allow click/long-press
                    } else {
                        qInfo() << "[GESTURE] discard non-book gesture"
                                << "start" << startPos << "end" << pos
                                << "tap=false long=false"
                                << "absDx" << absDx << "absDy" << absDy << "ms" << ms
                                << "isBookPage" << isBookPage
                                << "startInBottom" << candidateExit;
                    }
                }
            }
            inGesture = false;
            candidateExit = false;
            swallowThisGesture = false;
            buffered.clear();
        }
    }

    QUdpSocket socket;
    QHostAddress target;
    QUdpSocket stateSocket;
    bool inGesture = false;
    bool candidateExit = false;
    bool swallowThisGesture = false;
    bool menuActive = false;
    bool menuTap = false;
    QPointF startPos;
    QVector<Payload> buffered;
    qreal windowHeight = 1696.0;
    qreal windowWidth = 1404.0;
    QElapsedTimer elapsed;
    bool isBookPage = false; // updated via UDP 45456
    bool hasState = false;

    // thresholds
    const qreal bottomMargin = 100.0;
    const qreal exitDelta = 100.0;
    const qreal exitHorizTol = 200.0;
    const qreal leftEdge = 40.0;
    const qreal rightEdge = 40.0;
    const qreal topMargin = 80.0;
    const qreal backDelta = 200.0;
    const qreal backVertTol = 250.0;
    const qreal topHorizTol = 150.0;
    const qreal menuDelta = 100.0;
    const qreal menuTopHeight = 120.0;
    const qreal pageSwipeMin = 100.0;
    const qreal pageVertTol = 250.0;
    const qreal scrollMin = 100.0;
    const qreal tapThreshold = 100.0;
    const qint64 tapMs = 500;
    QUdpSocket stateRequestSocket;
    QTimer stateTimer;
    QTimer menuTimer;
};

class ExitHelper : public QObject {
    Q_OBJECT
public:
    explicit ExitHelper(QObject *parent = nullptr) : QObject(parent) {}
    Q_INVOKABLE void exitToXochitl() {
        QProcess::startDetached(QStringLiteral("/home/root/weread/exit-wechatread.sh"));
    }
};

int main(int argc, char *argv[]) {
    QCoreApplication::setApplicationVersion(QString::fromLatin1(kViewerVersion));
    QCoreApplication::setAttribute(Qt::AA_SynthesizeMouseForUnhandledTouchEvents);
    QCoreApplication::setAttribute(Qt::AA_SynthesizeTouchForUnhandledMouseEvents);
    QGuiApplication app(argc, argv);
    qInfo() << "[VIEWER] version" << QCoreApplication::applicationVersion();
    TouchSender sender;
    app.installEventFilter(&sender);
    QQmlApplicationEngine engine;

    auto provider = new ShmImageProvider();
    engine.addImageProvider("shmframe", provider);

    ShmWatcher watcher;
    if (!watcher.init("/dev/shm/weread_frame", provider)) {
        qWarning() << "Failed to init shm watcher";
    }
    engine.rootContext()->setContextProperty("shmWatcher", &watcher);

    ExitHelper exitHelper;
    engine.rootContext()->setContextProperty("exitHelper", &exitHelper);
    QObject::connect(&sender, &TouchSender::exitGestureDetected,
                     &exitHelper, &ExitHelper::exitToXochitl);

    using namespace Qt::StringLiterals;
    const QString qmlPath = QCoreApplication::applicationDirPath() + "/main.qml";
    const QUrl url = QUrl::fromLocalFile(qmlPath);
    QObject::connect(&engine, &QQmlApplicationEngine::objectCreated,
                     &app, [url](QObject *obj, const QUrl &objUrl) {
        if (!obj && url == objUrl) QCoreApplication::exit(-1);
    }, Qt::QueuedConnection);
    engine.load(url);
    return app.exec();
}

#include "main.moc"
